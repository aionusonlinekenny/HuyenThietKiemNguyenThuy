	TITLE	D:\HuyenThietKiemNguyenThuy\SwordOnline\Sources\Core\Src\KMissle.cpp
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT PARA USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT ??_C@_00A@?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BP@KLJH@invalid?5vector?$DMbool?$DO?5subscript?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0FG@ILEN@?3Sun?3Sunday?3Mon?3Monday?3Tue?3Tuesd@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0IH@JLLA@?3Jan?3January?3Feb?3February?3Mar?3Ma@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05NAGO@false?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04NCCD@true?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02ELCB@no?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_03LGKI@yes?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01FKHJ@C?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@MDID@MissleName?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@IMPH@MissleHeight?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08CLHE@LifeTime?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_05PDDA@Speed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0O@CEMO@ResponseSkill?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@IPHD@CollidRange?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09LLHA@ColVanish?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0N@MOFP@CanColFriend?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07ICPB@CanSlow?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@DOMN@IsRangeDmg?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08EKOK@DmgRange?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08MKEC@MoveKind?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@ICBE@FollowKind?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_04LIGI@Zacc?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06EDNA@Zspeed?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06DMFP@Param1?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06MDOG@Param2?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06GJHB@Param3?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@CDCB@AutoExplode?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@MLLA@DmgInterval?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_06PIMC@RedLum?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08KOFB@GreenLum?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07BJEB@BlueLum?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@HJOL@LightRadius?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09PDKK@MultiShow?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@EKAK@AnimFile?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_09CDAF@SndFile?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0P@EKPH@AnimFileInfo?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0M@LCCH@AnimFileB?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0L@HHEO@SndFileB?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@BPCH@AnimFileInfoB?$CFd?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08OBCD@LoopPlay?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07MAEH@SubLoop?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_08CAJJ@SubStart?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_07CKM@SubStop?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PAFJ@ColFollowTarget?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_02MHAC@?$CFp?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BH@CFAI@0123456789abcdefABCDEF?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KFAL@E?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01PHOL@e?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_01KMAE@?0?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_C@_0BF@MMAA@missing?5locale?5facet?$AA@
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CRT$XCA	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCA	ENDS
CRT$XCU	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCU	ENDS
CRT$XCL	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCL	ENDS
CRT$XCC	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCC	ENDS
CRT$XCZ	SEGMENT DWORD USE32 PUBLIC 'DATA'
CRT$XCZ	ENDS
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??4KMapMusic@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGameTime@KSubWorldSet@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetGameVersion@KSubWorldSet@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetPing@KSubWorldSet@@QAEXK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetPing@KSubWorldSet@@QAEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4KSubWorldSet@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1KSubWorldSet@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_DirSin@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_DirCos@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?qsqrt@@YAMM@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_GetDistance@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_GetDirIdxForFindPath@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_GetDirIndex@@YAHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_Dir2DirIndex@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_DirIndex2Dir@@YAHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?g_Square@@YAHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0KSkillSpecialNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1KSkillSpecialNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GKSkillSpecialNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMoney@KInventory@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SetMoney@KInventory@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4KInventory@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@CChatFriend@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCChatFriend@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CChatFriend@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GCChatApplyListNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1CChatApplyListNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@KTeamApplyList@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetBuildItem@KItemList@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetEquipment@KItemList@@QBEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMoney@KItemList@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Hand@KItemList@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMaskLock@KItemList@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsLockOperation@KItemList@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsActiveSet@KItemList@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4KItemList@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0KEquipmentArray@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1KEquipmentArray@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0bad_cast@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0bad_typeid@std@@QAE@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1bad_typeid@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0bad_typeid@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1__non_rtti_object@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0_Timevec@std@@QAE@PAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1_Timevec@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4_Timevec@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Incref@facet@locale@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Decref@facet@locale@std@@QAEPAV123@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1facet@locale@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0locale@std@@QAE@W4_Uninitialized@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1locale@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Narrow@std@@YAHG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Widen@std@@YAGDPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0codecvt_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1codecvt_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$codecvt@GDH@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Init@?$codecvt@GDH@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$ctype@D@std@@QAE@PBF_NI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$ctype@D@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Term@?$ctype@D@std@@KAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@D@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@failure@ios_base@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?setstate@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?fail@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?exceptions@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?setf@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?setf@ios_base@std@@QAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?unsetf@ios_base@std@@QAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?precision@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?width@ios_base@std@@QBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?width@ios_base@std@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0KMissleSet@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4KMissleSet@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1KMissleSet@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KSG_StringGetInt@@YAHPAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?KSG_StringSkipSymbol@@YA_NPAPADH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E32
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E33
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E34
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E35
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E37
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E38
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0KMissle@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GKMissle@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Release@KMissle@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1KMissle@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInfoFromTabFile@KMissle@@QAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Init@KMissle@@AAEHHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Activate@KMissle@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnWait@KMissle@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnCollision@KMissle@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckCollision@KMissle@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnFly@KMissle@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?OnVanish@KMissle@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Paint@KMissle@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckBeyondRegion@KMissle@@AAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4KMissle@@AAEAAV0@AAV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessDamage@KMissle@@AAEHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoVanish@KMissle@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoCollision@KMissle@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoFly@KMissle@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessCollision@KMissle@@AAEHHHHHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?ProcessCollision@KMissle@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CreateMissleForShow@KMissle@@SAHPAD00PAUTMissleForShow@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetLightInfo@KMissle@@QAEXPAUKLightInfo@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?DoWait@KMissle@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?PrePareFly@KMissle@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?CheckNearestCollision@KMissle@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?FindNearestCollision@KMissle@@AAEHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetMpsPos@KMissle@@QAEXPAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?reserve@?$vector@IV?$allocator@I@std@@@std@@QAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?resize@?$vector@IV?$allocator@I@std@@@std@@QAEXIABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?get_allocator@?$vector@IV?$allocator@I@std@@@std@@QBE?AV?$allocator@I@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAEPAIPAI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Eq@?$vector@IV?$allocator@I@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Lt@?$vector@IV?$allocator@I@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?swap@?$vector@IV?$allocator@I@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@Viterator@?$vector@_NV?$allocator@I@std@@@std@@_NVreference@23@PAV423@H@std@@QAE@Viterator@?$vector@_NV?$allocator@I@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$reverse_iterator@Vconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@_N$$CBVreference@23@PBV423@H@std@@QAE@Vconst_iterator@?$vector@_NV?$allocator@I@std@@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@FV?$allocator@F@std@@@std@@QAE@ABV?$allocator@F@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1?$vector@FV?$allocator@F@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?begin@?$vector@FV?$allocator@F@std@@@std@@QAEPAFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@FV?$allocator@F@std@@@std@@QAEPAFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?size@?$vector@FV?$allocator@F@std@@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??A?$vector@FV?$allocator@F@std@@@std@@QAEAAFI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_back@?$vector@FV?$allocator@F@std@@@std@@QAEXABF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?erase@?$vector@FV?$allocator@F@std@@@std@@QAEPAFPAF0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?is@?$ctype@G@std@@QBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$ctype@G@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_is@?$ctype@G@std@@MBE_NFG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_is@?$ctype@G@std@@MBEPBGPBG0PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_scan_is@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_scan_not@?$ctype@G@std@@MBEPBGFPBG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_tolower@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_tolower@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_toupper@?$ctype@G@std@@MBEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_toupper@?$ctype@G@std@@MBEPBGPAGPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_widen@?$ctype@G@std@@MBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_widen@?$ctype@G@std@@MBEPBDPBD0PAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_narrow@?$ctype@G@std@@MBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_narrow@?$ctype@G@std@@MBEPBGPBG0DPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$codecvt@DDH@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$numpunct@D@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$numpunct@G@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_decimal_point@?$numpunct@G@std@@MBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_thousands_sep@?$numpunct@G@std@@MBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_grouping@?$numpunct@G@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_falsename@?$numpunct@G@std@@MBE?AV?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?do_truename@?$numpunct@G@std@@MBE?AV?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$num_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_streambuf@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sgetc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?snextc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_ios@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?setstate@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?rdbuf@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_streambuf@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_ostream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?put@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?flush@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_istream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_istream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_iostream@GU?$char_traits@G@std@@@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$ctype@G@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@D@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_G?$numpunct@G@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_istream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_istream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_iostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??_D?$basic_iostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@IDABV?$allocator@D@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Nullstr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@ABV?$allocator@G@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@PBGABV?$allocator@G@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@IGABV?$allocator@G@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??4?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??Y?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV01@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?c_str@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAIIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@I@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$vector@IV?$allocator@I@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@IV?$allocator@I@std@@@std@@QAEXPAIIABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@IAEXPAI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ucopy@?$vector@IV?$allocator@I@std@@@std@@IAEPAIPBI0PAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@IAEXPAIIABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@FV?$allocator@F@std@@@std@@QAEPAFPAFABF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@FV?$allocator@F@std@@@std@@IAEXPAF0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@F@std@@QAEXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?widen@?$ctype@G@std@@QBEGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?narrow@?$ctype@G@std@@QBEDGD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?falsename@?$numpunct@G@std@@QBE?AV?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?truename@?$numpunct@G@std@@QBE?AV?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getifld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1HABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getffld@?$num_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@CAHPADAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@2@1ABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBEABDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getifld@?$num_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@CAHPADAAV?$istreambuf_iterator@GU?$char_traits@G@std@@@2@1HABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Getffld@?$num_get@GV?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@CAHPADAAV?$istreambuf_iterator@GU?$char_traits@G@std@@@2@1ABVlocale@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@QBEABGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@KAPADPADDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Fput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@KA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBDII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@KAPADPADDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@KA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@KA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Putc@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@KA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@KA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Ffmt@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@KAPADPADDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Fput@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@KA?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@AAVios_base@2@GPBDII@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Ifmt@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@KAPADPADDH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Iput@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@KA?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@AAVios_base@2@GPADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Put@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@KA?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@PBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Putc@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@KA?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Rep@?$num_put@GV?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@@std@@KA?AV?$ostreambuf_iterator@GU?$char_traits@G@std@@@2@V32@GI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$fpos@H@std@@QAE@J@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pubsync@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sbumpc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?sputc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@QAEGG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?gptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?egptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?gbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?epptr@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IBEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Gninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?pbump@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEXH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?clear@?$basic_ios@GU?$char_traits@G@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1sentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@GU?$char_traits@G@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?ipfx@?$basic_istream@GU?$char_traits@G@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Refcnt@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAEPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@IG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Eos@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Grow@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@AAE_NI_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Nullstr@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@CAPBGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Tidy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@AAEX_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@I@std@@QAEXPAIABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@I@std@@QAEXPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?insert@?$vector@FV?$allocator@F@std@@@std@@QAEXPAFIABF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@F@std@@QAEXPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?decimal_point@?$numpunct@G@std@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?thousands_sep@?$numpunct@G@std@@QBEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?grouping@?$numpunct@G@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@AAEDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Peek@?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@AAEGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@QAEAAV01@G@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??D?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??E?$ostreambuf_iterator@GU?$char_traits@G@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Pninc@?$basic_streambuf@GU?$char_traits@G@std@@@std@@IAEPAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?tie@?$basic_ios@GU?$char_traits@G@std@@@std@@QBEPAV?$basic_ostream@GU?$char_traits@G@std@@@2@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?opfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?opfx@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?osfx@?$basic_ostream@GU?$char_traits@G@std@@@std@@QAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Freeze@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Split@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?append@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@PBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?max_size@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Copy@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@AAEXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Refcnt@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@AAEAAEPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@G@std@@QAEXPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ucopy@?$vector@FV?$allocator@F@std@@@std@@IAEPAFPBF0PAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Ufill@?$vector@FV?$allocator@F@std@@@std@@IAEXPAFIABF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@F@std@@QAEPAFIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?erase@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?capacity@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@G@std@@QAEPAGIPBX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@G@std@@QBEIXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@F@std@@QAEXPAFABF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Split@?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy_backward@std@@YA?AViterator@?$vector@_NV?$allocator@I@std@@@1@V231@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@std@@YAXViterator@?$vector@_NV?$allocator@I@std@@@1@0AB_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Distance@std@@YAXVconst_iterator@?$vector@_NV?$allocator@I@std@@@1@0AAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@std@@YA?AViterator@?$vector@_NV?$allocator@I@std@@@1@Vconst_iterator@31@0V231@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@std@@YA?AViterator@?$vector@_NV?$allocator@I@std@@@1@V231@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?swap@std@@YAXAAI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?pop_heap@std@@YAXPAVOpenNodePtr@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?push_heap@std@@YAXPAVOpenNodePtr@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?make_heap@std@@YAXPAVOpenNodePtr@@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_facet@std@@YAABV?$ctype@D@1@ABVlocale@1@PBV21@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_facet@std@@YAABV?$ctype@G@1@ABVlocale@1@PBV21@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@std@@YAPAIPAI00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@std@@YA_NPBI00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?lexicographical_compare@std@@YA_NPBI000@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8std@@YA_NABV?$allocator@I@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?swap@std@@YAXAAPAI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@std@@YAPAFPAF00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_facet@std@@YAABV?$numpunct@D@1@ABVlocale@1@PBV21@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getloctxt@std@@YAHAAV?$istreambuf_iterator@DU?$char_traits@D@std@@@1@0IPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Widen@std@@YADDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?use_facet@std@@YAABV?$numpunct@G@1@ABVlocale@1@PBV21@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Getloctxt@std@@YAHAAV?$istreambuf_iterator@GU?$char_traits@G@std@@@1@0IPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8std@@YA_NABV?$istreambuf_iterator@GU?$char_traits@G@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Allocate@std@@YAPAIHPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy@std@@YAPAIPBI0PAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@std@@YAXPAI0ABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy_backward@std@@YAPAIPAI00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9std@@YA_NABV?$istreambuf_iterator@DU?$char_traits@D@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Narrow@std@@YAHD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?isdigit@std@@YA_NDABVlocale@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9std@@YA_NABV?$istreambuf_iterator@GU?$char_traits@G@std@@@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Construct@std@@YAXPAIABI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@std@@YAXPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?fill@std@@YAXPAF0ABF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?copy_backward@std@@YAPAFPAF00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Destroy@std@@YAXPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8std@@YA_NABV?$allocator@G@0@0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Allocate@std@@YAPAFHPAF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Allocate@std@@YAPADHPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Allocate@std@@YAPAGHPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Construct@std@@YAXPAFABF@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$ctype@G@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$numpunct@D@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0?$numpunct@G@std@@QAE@I@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?equal@?$istreambuf_iterator@GU?$char_traits@G@std@@@std@@QBE_NABV12@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Save@?$_Tidyfac@V?$ctype@D@std@@@std@@SAPAV?$ctype@D@2@PAV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Save@?$_Tidyfac@V?$ctype@G@std@@@std@@SAPAV?$ctype@G@2@PAV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Save@?$_Tidyfac@V?$numpunct@D@std@@@std@@SAPAV?$numpunct@D@2@PAV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Save@?$_Tidyfac@V?$numpunct@G@std@@@std@@SAPAV?$numpunct@G@2@PAV32@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Init@?$ctype@G@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?_Init@?$numpunct@G@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tidyfac@V?$ctype@D@std@@@std@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tidyfac@V?$ctype@G@std@@@std@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tidyfac@V?$numpunct@D@std@@@std@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Tidy@?$_Tidyfac@V?$numpunct@G@std@@@std@@SAXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Iter_cat@std@@YA?AUrandom_access_iterator_tag@1@ABU?$iterator@Urandom_access_iterator_tag@std@@_NH@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Distance@std@@YAXVconst_iterator@?$vector@_NV?$allocator@I@std@@@1@0AAIUrandom_access_iterator_tag@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Val_type@std@@YAPAVOpenNodePtr@@PBV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pop_heap_0@std@@YAXPAVOpenNodePtr@@00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dist_type@std@@YAPAHPBVOpenNodePtr@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Push_heap_0@std@@YAXPAVOpenNodePtr@@0PAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Make_heap@std@@YAXPAVOpenNodePtr@@0PAH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?mismatch@std@@YA?AU?$pair@PBIPBI@1@PBI00@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Maklocstr@std@@YAPADPBDPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Maklocstr@std@@YAPAGPBDPAG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0?$pair@PBIPBI@std@@QAE@ABQBI0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Pop_heap@std@@YAXPAVOpenNodePtr@@00V2@PAH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Push_heap@std@@YAXPAVOpenNodePtr@@HHV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Adjust_heap@std@@YAXPAVOpenNodePtr@@HHV2@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GKNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Doraise@invalid_argument@std@@MBEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0invalid_argument@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7invalid_argument@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __TI3?AVinvalid_argument@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVinvalid_argument@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVinvalid_argument@std@@@8??0invalid_argument@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __imp_?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_Ginvalid_argument@std@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GKWorldMsgNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1KWorldMsgNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?SetName@KStrNode@@UAEXPAD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?GetName@KStrNode@@UAEPADXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GKCacheNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1KCacheNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??1KStrNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GKIndexNode@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSkillLevelUpScriptId@ISkill@@UBEKXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsExpSkill@ISkill@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetSkillAttrib@ISkill@@UBEFXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsPhysical@ISkill@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsAura@ISkill@@UBEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_GISkill@@UAEPAXI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??1ISkill@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7ISkill@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??MOpenNodePtr@@QAE_NABV0@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Gconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBEHV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Facsav@?$_Tidyfac@V?$numpunct@G@std@@@std@@0PAV?$numpunct@G@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Facsav@?$_Tidyfac@V?$numpunct@D@std@@@std@@0PAV?$numpunct@D@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Facsav@?$_Tidyfac@V?$ctype@G@std@@@std@@0PAV?$ctype@G@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ?_Facsav@?$_Tidyfac@V?$ctype@D@std@@@std@@0PAV?$ctype@D@2@A
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_S?$numpunct@G@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?1??use_facet@std@@YAABV?$numpunct@G@2@ABVlocale@2@PBV32@_N@Z@4PBVfacet@42@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_S?$numpunct@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?1??use_facet@std@@YAABV?$numpunct@D@2@ABVlocale@2@PBV32@_N@Z@4PBVfacet@42@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_S?$ctype@G@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?1??use_facet@std@@YAABV?$ctype@G@2@ABVlocale@2@PBV32@_N@Z@4PBVfacet@42@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??_S?$ctype@D@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?_Psave@?1??use_facet@std@@YAABV?$ctype@D@2@ABVlocale@2@PBV32@_N@Z@4PBVfacet@42@B
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT ??Dconst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE?BVreference@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0reference@?$vector@_NV?$allocator@I@std@@@std@@QAE@IPAI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9const_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8const_iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Econst_iterator@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Inc@const_iterator@?$vector@_NV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4reference@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@_N@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Eiterator@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Fiterator@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?_Dec@const_iterator@?$vector@_NV?$allocator@I@std@@@std@@IAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Diterator@?$vector@_NV?$allocator@I@std@@@std@@QBE?AVreference@12@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??4reference@?$vector@_NV?$allocator@I@std@@@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??Breference@?$vector@_NV?$allocator@I@std@@@std@@QBE_NXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??9iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??8iterator@?$vector@_NV?$allocator@I@std@@@std@@QBE_NABV012@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?move@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemmove
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$char_traits@G@std@@SAXAAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?length@?$char_traits@G@std@@SAIPBG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$char_traits@G@std@@SAPAGPAGIABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemset
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?assign@?$char_traits@D@std@@SAPADPADIABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?copy@?$char_traits@G@std@@SAPAGPAGPBGI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _wmemcpy
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?to_int_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?AddTail@KList@@QAEXPAVKNode@@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?InsertBefore@KNode@@QAEXPAV1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetNext@KNode@@QAEPAV1@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?GetHead@KList@@QAEPAVKNode@@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?SpecialMovieIsAllEnd@KMissleRes@@QAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?Send@KWorldMsg@@QAEHKHHH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0KWorldMsgNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7KWorldMsgNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?ZAxisMove@KMissle@@AAEXXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?TestBarrier@KMissle@@AAEHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ?IsMatch@KNpc@@QAEHK@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7KMissle@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1KIndexNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??0KIndexNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7KIndexNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ?GetSkill@KSkillManager@@QAEPAVISkill@@HH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?to_char_type@?$char_traits@G@std@@SAGABG@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?eof@?$char_traits@G@std@@SAGXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?eq_int_type@?$char_traits@G@std@@SA_NABG0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA3?AVfailure@ios_base@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z28
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI3?AVfailure@ios_base@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT __imp_??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __imp_??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT __CTA2?AVbad_typeid@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_typeid@std@@@8??0bad_typeid@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_typeid@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_typeid@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@@@8??0exception@@QAE@ABV0@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT DWORD USE32 PUBLIC 'CONST'
xdata$x	ENDS
;	COMDAT __imp_??0KLinkArray@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7CChatApplyListNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7CChatFriend@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??_7KSkillSpecialNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??1KNode@@UAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT ??_7KNode@@6B@
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
;	COMDAT ??0KNode@@QAE@XZ
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
FLAT	GROUP _DATA, CONST, _BSS, CRT$XCA, CRT$XCU, CRT$XCL, CRT$XCC, CRT$XCZ, xdata$x
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif
PUBLIC	?g_CollisionMatrix@@3PAUTCollisionMatrix@@A	; g_CollisionMatrix
PUBLIC	?g_nRandMissleTab@@3PAHA			; g_nRandMissleTab
PUBLIC	?Missle@@3PAVKMissle@@A				; Missle
PUBLIC	?g_MisslesLib@@3PAVKMissle@@A			; g_MisslesLib
_BSS	SEGMENT
?g_nRandMissleTab@@3PAHA DD 064H DUP (?)		; g_nRandMissleTab
?Missle@@3PAVKMissle@@A DB 0167600H DUP (?)		; Missle
?g_MisslesLib@@3PAVKMissle@@A DB 0143700H DUP (?)	; g_MisslesLib
_BSS	ENDS
CONST	SEGMENT
_bias	DD	04b400000H
	ORG $+4
_sqrttable DD	01fb55f5fH
	DD	01fb613b0H
	DD	01fb6c74fH
	DD	01fb77a3fH
	DD	01fb82c80H
	DD	01fb8de16H
	DD	01fb98f01H
	DD	01fba3f45H
	DD	01fbaeee2H
	DD	01fbb9ddbH
	DD	01fbc4c32H
	DD	01fbcf9e8H
	DD	01fbda6feH
	DD	01fbe5377H
	DD	01fbeff54H
	DD	01fbfaa98H
	DD	01fc05542H
	DD	01fc0ff56H
	DD	01fc1a8d5H
	DD	01fc251bfH
	DD	01fc2fa18H
	DD	01fc3a1dfH
	DD	01fc44917H
	DD	01fc4efc1H
	DD	01fc595deH
	DD	01fc63b71H
	DD	01fc6e079H
	DD	01fc784f9H
	DD	01fc828f2H
	DD	01fc8cc64H
	DD	01fc96f53H
	DD	01fca11bdH
	DD	01fcab3a6H
	DD	01fcb550eH
	DD	01fcbf5f6H
	DD	01fcc965fH
	DD	01fcd364bH
	DD	01fcdd5bbH
	DD	01fce74b0H
	DD	01fcf132aH
	DD	01fcfb12cH
	DD	01fd04eb6H
	DD	01fd0ebc9H
	DD	01fd18866H
	DD	01fd2248fH
	DD	01fd2c044H
	DD	01fd35b86H
	DD	01fd3f657H
	DD	01fd490b6H
	DD	01fd52aa6H
	DD	01fd5c427H
	DD	01fd65d3bH
	DD	01fd6f5e1H
	DD	01fd78e1bH
	DD	01fd825eaH
	DD	01fd8bd4eH
	DD	01fd95449H
	DD	01fd9eadcH
	DD	01fda8106H
	DD	01fdb16caH
	DD	01fdbac28H
	DD	01fdc4120H
	DD	01fdcd5b4H
	DD	01fdd69e4H
	DD	01fddfdb2H
	DD	01fde911dH
	DD	01fdf2426H
	DD	01fdfb6cfH
	DD	01fe04919H
	DD	01fe0db03H
	DD	01fe16c8eH
	DD	01fe1fdbcH
	DD	01fe28e8dH
	DD	01fe31f01H
	DD	01fe3af1aH
	DD	01fe43ed8H
	DD	01fe4ce3bH
	DD	01fe55d45H
	DD	01fe5ebf6H
	DD	01fe67a4fH
	DD	01fe70850H
	DD	01fe795f9H
	DD	01fe8234dH
	DD	01fe8b04aH
	DD	01fe93cf3H
	DD	01fe9c946H
	DD	01fea5546H
	DD	01feae0f2H
	DD	01feb6c4bH
	DD	01febf752H
	DD	01fec8208H
	DD	01fed0c6cH
	DD	01fed967fH
	DD	01fee2043H
	DD	01feea9b7H
	DD	01fef32dcH
	DD	01fefbbb2H
	DD	01ff0443bH
	DD	01ff0cc76H
	DD	01ff15464H
	DD	01ff1dc06H
	DD	01ff2635cH
	DD	01ff2ea66H
	DD	01ff37126H
	DD	01ff3f79bH
	DD	01ff47dc6H
	DD	01ff503a8H
	DD	01ff58941H
	DD	01ff60e91H
	DD	01ff69399H
	DD	01ff7185aH
	DD	01ff79cd3H
	DD	01ff82106H
	DD	01ff8a4f2H
	DD	01ff92899H
	DD	01ff9abfaH
	DD	01ffa2f16H
	DD	01ffab1eeH
	DD	01ffb3481H
	DD	01ffbb6d1H
	DD	01ffc38ddH
	DD	01ffcbaa7H
	DD	01ffd3c2dH
	DD	01ffdbd72H
	DD	01ffe3e75H
	DD	01ffebf37H
	DD	01fff3fb8H
	DD	01fffbff8H
	DD	020003ff0H
	DD	02000bf71H
	DD	020013e74H
	DD	02001bcfbH
	DD	020023b06H
	DD	02002b899H
	DD	0200335b3H
	DD	02003b256H
	DD	020042e83H
	DD	02004aa3dH
	DD	020052583H
	DD	02005a058H
	DD	020061abcH
	DD	0200694b1H
	DD	020070e38H
	DD	020078752H
	DD	020080000H
	DD	020087843H
	DD	02008f01dH
	DD	02009678eH
	DD	02009de98H
	DD	0200a553bH
	DD	0200acb79H
	DD	0200b4152H
	DD	0200bb6c8H
	DD	0200c2bdcH
	DD	0200ca08eH
	DD	0200d14e0H
	DD	0200d88d2H
	DD	0200dfc65H
	DD	0200e6f9aH
	DD	0200ee273H
	DD	0200f54f0H
	DD	0200fc711H
	DD	0201038d8H
	DD	02010aa46H
	DD	020111b5bH
	DD	020118c18H
	DD	02011fc7eH
	DD	020126c8eH
	DD	02012dc48H
	DD	020134baeH
	DD	02013babfH
	DD	02014297eH
	DD	0201497e9H
	DD	020150603H
	DD	0201573ccH
	DD	02015e145H
	DD	020164e6dH
	DD	02016bb47H
	DD	0201727d2H
	DD	020179410H
	DD	020180000H
	DD	020186ba4H
	DD	02018d6fcH
	DD	020194209H
	DD	02019acccH
	DD	0201a1744H
	DD	0201a8173H
	DD	0201aeb59H
	DD	0201b54f8H
	DD	0201bbe4eH
	DD	0201c275dH
	DD	0201c9026H
	DD	0201cf8a9H
	DD	0201d60e7H
	DD	0201dc8e0H
	DD	0201e3094H
	DD	0201e9805H
	DD	0201eff32H
	DD	0201f661cH
	DD	0201fccc5H
	DD	02020332bH
	DD	020209950H
	DD	02020ff34H
	DD	0202164d8H
	DD	02021ca3dH
	DD	020222f61H
	DD	020229447H
	DD	02022f8efH
	DD	020235d58H
	DD	02023c184H
	DD	020242572H
	DD	020248924H
	DD	02024ec9aH
	DD	020254fd4H
	DD	02025b2d2H
	DD	020261596H
	DD	02026781fH
	DD	02026da6dH
	DD	020273c82H
	DD	020279e5eH
	DD	020280000H
	DD	02028616aH
	DD	02028c29bH
	DD	020292395H
	DD	020298458H
	DD	02029e4e3H
	DD	0202a4537H
	DD	0202aa555H
	DD	0202b053dH
	DD	0202b64f0H
	DD	0202bc46dH
	DD	0202c23b5H
	DD	0202c82c8H
	DD	0202ce1a8H
	DD	0202d4053H
	DD	0202d9ecaH
	DD	0202dfd0fH
	DD	0202e5b20H
	DD	0202eb8ffH
	DD	0202f16abH
	DD	0202f7426H
	DD	0202fd16eH
	DD	020302e85H
	DD	020308b6cH
	DD	02030e821H
	DD	0203144a6H
	DD	02031a0fbH
	DD	02031fd20H
	DD	020325915H
	DD	02032b4dbH
	DD	020331072H
	DD	020336bdaH
	DD	02033c713H
	DD	02034221fH
	DD	020347cfcH
	DD	02034d7acH
CONST	ENDS
_DATA	SEGMENT
?g_CollisionMatrix@@3PAUTCollisionMatrix@@A DD 00H	; g_CollisionMatrix
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	01H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
_DATA	ENDS
CRT$XCU	SEGMENT
_$S36	DD	FLAT:_$E35
_$S41	DD	FLAT:_$E40
CRT$XCU	ENDS
PUBLIC	??4KMapMusic@@QAEAAV0@ABV0@@Z			; KMapMusic::operator=
;	COMDAT ??4KMapMusic@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4KMapMusic@@QAEAAV0@ABV0@@Z PROC NEAR			; KMapMusic::operator=, COMDAT
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	mov	eax, ecx
	push	edi
	mov	ecx, 12351				; 0000303fH
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	ret	4
??4KMapMusic@@QAEAAV0@ABV0@@Z ENDP			; KMapMusic::operator=
_TEXT	ENDS
PUBLIC	?GetGameTime@KSubWorldSet@@QAEHXZ		; KSubWorldSet::GetGameTime
;	COMDAT ?GetGameTime@KSubWorldSet@@QAEHXZ
_TEXT	SEGMENT
?GetGameTime@KSubWorldSet@@QAEHXZ PROC NEAR		; KSubWorldSet::GetGameTime, COMDAT

; 32   : 	int		GetGameTime(){return m_nLoopRate;};

	mov	eax, DWORD PTR [ecx]
	ret	0
?GetGameTime@KSubWorldSet@@QAEHXZ ENDP			; KSubWorldSet::GetGameTime
_TEXT	ENDS
PUBLIC	?GetGameVersion@KSubWorldSet@@QAEHXZ		; KSubWorldSet::GetGameVersion
;	COMDAT ?GetGameVersion@KSubWorldSet@@QAEHXZ
_TEXT	SEGMENT
?GetGameVersion@KSubWorldSet@@QAEHXZ PROC NEAR		; KSubWorldSet::GetGameVersion, COMDAT

; 33   : 	int		GetGameVersion() { return m_nGameVersion; }

	mov	eax, DWORD PTR [ecx+49408]
	ret	0
?GetGameVersion@KSubWorldSet@@QAEHXZ ENDP		; KSubWorldSet::GetGameVersion
_TEXT	ENDS
PUBLIC	?SetPing@KSubWorldSet@@QAEXK@Z			; KSubWorldSet::SetPing
;	COMDAT ?SetPing@KSubWorldSet@@QAEXK@Z
_TEXT	SEGMENT
_dwTimer$ = 8
?SetPing@KSubWorldSet@@QAEXK@Z PROC NEAR		; KSubWorldSet::SetPing, COMDAT

; 42   : 	void	SetPing(DWORD dwTimer) { m_dwPing = dwTimer; }

	mov	eax, DWORD PTR _dwTimer$[esp-4]
	mov	DWORD PTR [ecx+49412], eax
	ret	4
?SetPing@KSubWorldSet@@QAEXK@Z ENDP			; KSubWorldSet::SetPing
_TEXT	ENDS
PUBLIC	?GetPing@KSubWorldSet@@QAEKXZ			; KSubWorldSet::GetPing
;	COMDAT ?GetPing@KSubWorldSet@@QAEKXZ
_TEXT	SEGMENT
?GetPing@KSubWorldSet@@QAEKXZ PROC NEAR			; KSubWorldSet::GetPing, COMDAT

; 43   : 	DWORD	GetPing() { return m_dwPing; }

	mov	eax, DWORD PTR [ecx+49412]
	ret	0
?GetPing@KSubWorldSet@@QAEKXZ ENDP			; KSubWorldSet::GetPing
_TEXT	ENDS
PUBLIC	??4KSubWorldSet@@QAEAAV0@ABV0@@Z		; KSubWorldSet::operator=
;	COMDAT ??4KSubWorldSet@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4KSubWorldSet@@QAEAAV0@ABV0@@Z PROC NEAR		; KSubWorldSet::operator=, COMDAT
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	mov	eax, ecx
	push	edi
	mov	ecx, 12354				; 00003042H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	ret	4
??4KSubWorldSet@@QAEAAV0@ABV0@@Z ENDP			; KSubWorldSet::operator=
_TEXT	ENDS
PUBLIC	??1KSubWorldSet@@QAE@XZ				; KSubWorldSet::~KSubWorldSet
EXTRN	??1KMapMusic@@QAE@XZ:NEAR			; KMapMusic::~KMapMusic
;	COMDAT ??1KSubWorldSet@@QAE@XZ
_TEXT	SEGMENT
??1KSubWorldSet@@QAE@XZ PROC NEAR			; KSubWorldSet::~KSubWorldSet, COMDAT
	add	ecx, 4
	jmp	??1KMapMusic@@QAE@XZ			; KMapMusic::~KMapMusic
??1KSubWorldSet@@QAE@XZ ENDP				; KSubWorldSet::~KSubWorldSet
_TEXT	ENDS
PUBLIC	?GetMoney@KInventory@@QAEHXZ			; KInventory::GetMoney
;	COMDAT ?GetMoney@KInventory@@QAEHXZ
_TEXT	SEGMENT
?GetMoney@KInventory@@QAEHXZ PROC NEAR			; KInventory::GetMoney, COMDAT

; 29   : 	int		GetMoney() { return m_nMoney; }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?GetMoney@KInventory@@QAEHXZ ENDP			; KInventory::GetMoney
_TEXT	ENDS
PUBLIC	?SetMoney@KInventory@@QAEHH@Z			; KInventory::SetMoney
;	COMDAT ?SetMoney@KInventory@@QAEHH@Z
_TEXT	SEGMENT
_nMoney$ = 8
?SetMoney@KInventory@@QAEHH@Z PROC NEAR			; KInventory::SetMoney, COMDAT

; 30   : 	BOOL	SetMoney(int nMoney) { if (nMoney < 0) return FALSE; m_nMoney = nMoney; return TRUE; }

	mov	eax, DWORD PTR _nMoney$[esp-4]
	test	eax, eax
	jge	SHORT $L92664
	xor	eax, eax
	ret	4
$L92664:
	mov	DWORD PTR [ecx+4], eax
	mov	eax, 1
	ret	4
?SetMoney@KInventory@@QAEHH@Z ENDP			; KInventory::SetMoney
_TEXT	ENDS
PUBLIC	??4KInventory@@QAEAAV0@ABV0@@Z			; KInventory::operator=
;	COMDAT ??4KInventory@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4KInventory@@QAEAAV0@ABV0@@Z PROC NEAR		; KInventory::operator=, COMDAT
	mov	eax, ecx
	push	esi
	mov	ecx, DWORD PTR ___that$[esp]
	mov	edx, eax
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], esi
	pop	esi
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	ret	4
??4KInventory@@QAEAAV0@ABV0@@Z ENDP			; KInventory::operator=
_TEXT	ENDS
PUBLIC	?GetBuildItem@KItemList@@QAEHH@Z		; KItemList::GetBuildItem
;	COMDAT ?GetBuildItem@KItemList@@QAEHH@Z
_TEXT	SEGMENT
_nIdx$ = 8
?GetBuildItem@KItemList@@QAEHH@Z PROC NEAR		; KItemList::GetBuildItem, COMDAT

; 99   : 	int			GetBuildItem(int nIdx) { return m_BuildItem[nIdx];}	 //TrembleItem by kinnox;

	mov	eax, DWORD PTR _nIdx$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+20552]
	ret	4
?GetBuildItem@KItemList@@QAEHH@Z ENDP			; KItemList::GetBuildItem
_TEXT	ENDS
PUBLIC	?GetEquipment@KItemList@@QBEHH@Z		; KItemList::GetEquipment
;	COMDAT ?GetEquipment@KItemList@@QBEHH@Z
_TEXT	SEGMENT
_nIdx$ = 8
?GetEquipment@KItemList@@QBEHH@Z PROC NEAR		; KItemList::GetEquipment, COMDAT

; 103  : 	int			GetEquipment(int nIdx) const { return m_EquipItem[nIdx]; }

	mov	eax, DWORD PTR _nIdx$[esp-4]
	mov	eax, DWORD PTR [ecx+eax*4+20592]
	ret	4
?GetEquipment@KItemList@@QBEHH@Z ENDP			; KItemList::GetEquipment
_TEXT	ENDS
PUBLIC	?GetMoney@KItemList@@QAEHH@Z			; KItemList::GetMoney
;	COMDAT ?GetMoney@KItemList@@QAEHH@Z
_TEXT	SEGMENT
_nRoom$ = 8
?GetMoney@KItemList@@QAEHH@Z PROC NEAR			; KItemList::GetMoney, COMDAT

; 150  : 	int			GetMoney(int nRoom) { return m_Room[nRoom].GetMoney(); }

	mov	eax, DWORD PTR _nRoom$[esp-4]
	add	eax, 1291				; 0000050bH
	shl	eax, 4
	mov	eax, DWORD PTR [eax+ecx]
	ret	4
?GetMoney@KItemList@@QAEHH@Z ENDP			; KItemList::GetMoney
_TEXT	ENDS
PUBLIC	?Hand@KItemList@@QAEHXZ				; KItemList::Hand
;	COMDAT ?Hand@KItemList@@QAEHXZ
_TEXT	SEGMENT
?Hand@KItemList@@QAEHXZ PROC NEAR			; KItemList::Hand, COMDAT

; 152  : 	int			Hand() { return m_Hand; };

	mov	eax, DWORD PTR [ecx+8]
	ret	0
?Hand@KItemList@@QAEHXZ ENDP				; KItemList::Hand
_TEXT	ENDS
PUBLIC	?GetMaskLock@KItemList@@QAEHXZ			; KItemList::GetMaskLock
;	COMDAT ?GetMaskLock@KItemList@@QAEHXZ
_TEXT	SEGMENT
?GetMaskLock@KItemList@@QAEHXZ PROC NEAR		; KItemList::GetMaskLock, COMDAT

; 161  : 	BOOL		GetMaskLock() {return m_bMaskLock;};

	xor	eax, eax
	mov	al, BYTE PTR [ecx+20549]
	ret	0
?GetMaskLock@KItemList@@QAEHXZ ENDP			; KItemList::GetMaskLock
_TEXT	ENDS
PUBLIC	?IsLockOperation@KItemList@@QAEHXZ		; KItemList::IsLockOperation
;	COMDAT ?IsLockOperation@KItemList@@QAEHXZ
_TEXT	SEGMENT
?IsLockOperation@KItemList@@QAEHXZ PROC NEAR		; KItemList::IsLockOperation, COMDAT

; 228  : 	BOOL		IsLockOperation() { return m_bLockOperation; };

	xor	eax, eax
	mov	al, BYTE PTR [ecx+20588]
	ret	0
?IsLockOperation@KItemList@@QAEHXZ ENDP			; KItemList::IsLockOperation
_TEXT	ENDS
PUBLIC	?IsActiveSet@KItemList@@QBEHXZ			; KItemList::IsActiveSet
;	COMDAT ?IsActiveSet@KItemList@@QBEHXZ
_TEXT	SEGMENT
?IsActiveSet@KItemList@@QBEHXZ PROC NEAR		; KItemList::IsActiveSet, COMDAT

; 245  : 	inline	int	IsActiveSet() const { return m_bActiveSet; };

	xor	eax, eax
	mov	al, BYTE PTR [ecx+20548]
	ret	0
?IsActiveSet@KItemList@@QBEHXZ ENDP			; KItemList::IsActiveSet
_TEXT	ENDS
PUBLIC	??4KItemList@@QAEAAV0@ABV0@@Z			; KItemList::operator=
;	COMDAT ??4KItemList@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4KItemList@@QAEAAV0@ABV0@@Z PROC NEAR			; KItemList::operator=, COMDAT
	push	esi
	mov	esi, DWORD PTR ___that$[esp]
	mov	eax, ecx
	push	edi
	mov	ecx, 5219				; 00001463H
	mov	edi, eax
	rep movsd
	pop	edi
	pop	esi
	ret	4
??4KItemList@@QAEAAV0@ABV0@@Z ENDP			; KItemList::operator=
_TEXT	ENDS
PUBLIC	??0KMissleSet@@QAE@XZ				; KMissleSet::KMissleSet
;	COMDAT ??0KMissleSet@@QAE@XZ
_TEXT	SEGMENT
??0KMissleSet@@QAE@XZ PROC NEAR				; KMissleSet::KMissleSet, COMDAT
	mov	eax, ecx
	xor	ecx, ecx
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], ecx
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+12], ecx
	ret	0
??0KMissleSet@@QAE@XZ ENDP				; KMissleSet::KMissleSet
_TEXT	ENDS
PUBLIC	??4KMissleSet@@QAEAAV0@ABV0@@Z			; KMissleSet::operator=
;	COMDAT ??4KMissleSet@@QAEAAV0@ABV0@@Z
_TEXT	SEGMENT
___that$ = 8
??4KMissleSet@@QAEAAV0@ABV0@@Z PROC NEAR		; KMissleSet::operator=, COMDAT
	mov	eax, ecx
	push	esi
	mov	ecx, DWORD PTR ___that$[esp]
	mov	edx, eax
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [edx], esi
	mov	esi, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], esi
	mov	esi, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], esi
	pop	esi
	mov	ecx, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+12], ecx
	ret	4
??4KMissleSet@@QAEAAV0@ABV0@@Z ENDP			; KMissleSet::operator=
_TEXT	ENDS
PUBLIC	??1KMissleSet@@QAE@XZ				; KMissleSet::~KMissleSet
EXTRN	__except_list:DWORD
EXTRN	___CxxFrameHandler:NEAR
EXTRN	__imp_??1KLinkArray@@QAE@XZ:NEAR
;	COMDAT xdata$x
xdata$x	SEGMENT
$T105886 DD	019930520H
	DD	01H
	DD	FLAT:$T105889
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T105889 DD	0ffffffffH
	DD	FLAT:$L105881
xdata$x	ENDS
;	COMDAT ??1KMissleSet@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1KMissleSet@@QAE@XZ PROC NEAR				; KMissleSet::~KMissleSet, COMDAT
	push	-1
	push	$L105887
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$[esp+24], esi
	mov	edi, DWORD PTR __imp_??1KLinkArray@@QAE@XZ
	lea	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR __$EHRec$[esp+32], 0
	call	edi
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[esp+32], -1
	call	edi
	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	pop	edi
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L105881:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1KLinkArray@@QAE@XZ
$L105887:
	mov	eax, OFFSET FLAT:$T105886
	jmp	___CxxFrameHandler
text$x	ENDS
??1KMissleSet@@QAE@XZ ENDP				; KMissleSet::~KMissleSet
;	COMDAT _$E35
_TEXT	SEGMENT
_$E35	PROC NEAR					; COMDAT
	call	_$E32
	jmp	_$E34
_$E35	ENDP
_TEXT	ENDS
PUBLIC	??0KMissle@@QAE@XZ				; KMissle::KMissle
PUBLIC	??1KMissle@@UAE@XZ				; KMissle::~KMissle
EXTRN	??_L@YGXPAXIHP6EX0@Z1@Z:NEAR			; `eh vector constructor iterator'
;	COMDAT _$E32
_TEXT	SEGMENT
_$E32	PROC NEAR					; COMDAT

; 111  : KMissle g_MisslesLib[MAX_MISSLESTYLE];

	push	OFFSET FLAT:??1KMissle@@UAE@XZ		; KMissle::~KMissle
	push	OFFSET FLAT:??0KMissle@@QAE@XZ		; KMissle::KMissle
	push	450					; 000001c2H
	push	2944					; 00000b80H
	push	OFFSET FLAT:?g_MisslesLib@@3PAVKMissle@@A ; g_MisslesLib
	call	??_L@YGXPAXIHP6EX0@Z1@Z			; `eh vector constructor iterator'
	ret	0
_$E32	ENDP
_TEXT	ENDS
EXTRN	_atexit:NEAR
;	COMDAT _$E34
_TEXT	SEGMENT
_$E34	PROC NEAR					; COMDAT
	push	OFFSET FLAT:_$E33
	call	_atexit
	pop	ecx
	ret	0
_$E34	ENDP
_TEXT	ENDS
EXTRN	??_M@YGXPAXIHP6EX0@Z@Z:NEAR			; `eh vector destructor iterator'
;	COMDAT _$E33
_TEXT	SEGMENT
_$E33	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??1KMissle@@UAE@XZ		; KMissle::~KMissle
	push	450					; 000001c2H
	push	2944					; 00000b80H
	push	OFFSET FLAT:?g_MisslesLib@@3PAVKMissle@@A ; g_MisslesLib
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	ret	0
_$E33	ENDP
_TEXT	ENDS
;	COMDAT _$E40
_TEXT	SEGMENT
_$E40	PROC NEAR					; COMDAT
	call	_$E37
	jmp	_$E39
_$E40	ENDP
_TEXT	ENDS
;	COMDAT _$E37
_TEXT	SEGMENT
_$E37	PROC NEAR					; COMDAT

; 129  : CORE_API KMissle Missle[MAX_MISSLE];

	push	OFFSET FLAT:??1KMissle@@UAE@XZ		; KMissle::~KMissle
	push	OFFSET FLAT:??0KMissle@@QAE@XZ		; KMissle::KMissle
	push	500					; 000001f4H
	push	2944					; 00000b80H
	push	OFFSET FLAT:?Missle@@3PAVKMissle@@A	; Missle
	call	??_L@YGXPAXIHP6EX0@Z1@Z			; `eh vector constructor iterator'
	ret	0
_$E37	ENDP
_TEXT	ENDS
;	COMDAT _$E39
_TEXT	SEGMENT
_$E39	PROC NEAR					; COMDAT
	push	OFFSET FLAT:_$E38
	call	_atexit
	pop	ecx
	ret	0
_$E39	ENDP
_TEXT	ENDS
;	COMDAT _$E38
_TEXT	SEGMENT
_$E38	PROC NEAR					; COMDAT
	push	OFFSET FLAT:??1KMissle@@UAE@XZ		; KMissle::~KMissle
	push	500					; 000001f4H
	push	2944					; 00000b80H
	push	OFFSET FLAT:?Missle@@3PAVKMissle@@A	; Missle
	call	??_M@YGXPAXIHP6EX0@Z@Z			; `eh vector destructor iterator'
	ret	0
_$E38	ENDP
_TEXT	ENDS
PUBLIC	??_7KMissle@@6B@				; KMissle::`vftable'
PUBLIC	??_GKMissle@@UAEPAXI@Z				; KMissle::`scalar deleting destructor'
PUBLIC	??_EKMissle@@UAEPAXI@Z				; KMissle::`vector deleting destructor'
PUBLIC	??1KIndexNode@@UAE@XZ				; KIndexNode::~KIndexNode
PUBLIC	??_7KIndexNode@@6B@				; KIndexNode::`vftable'
PUBLIC	??_GKIndexNode@@UAEPAXI@Z			; KIndexNode::`scalar deleting destructor'
PUBLIC	??_EKIndexNode@@UAEPAXI@Z			; KIndexNode::`vector deleting destructor'
EXTRN	??0KMissleRes@@QAE@XZ:NEAR			; KMissleRes::KMissleRes
;	COMDAT ??_7KIndexNode@@6B@
; File ..\engine\src\KNode.h
CONST	SEGMENT
??_7KIndexNode@@6B@ DD FLAT:??_EKIndexNode@@UAEPAXI@Z	; KIndexNode::`vftable'
CONST	ENDS
;	COMDAT ??_7KMissle@@6B@
CONST	SEGMENT
??_7KMissle@@6B@ DD FLAT:??_EKMissle@@UAEPAXI@Z		; KMissle::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T105933 DD	019930520H
	DD	01H
	DD	FLAT:$T105935
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T105935 DD	0ffffffffH
	DD	FLAT:$L105920
xdata$x	ENDS
;	COMDAT ??0KMissle@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??0KMissle@@QAE@XZ PROC NEAR				; KMissle::KMissle, COMDAT

; 135  : {

	push	-1
	push	$L105934
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx
	xor	ebx, ebx
	mov	DWORD PTR _this$[esp+24], esi
	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], ebx
	mov	DWORD PTR [esi+4], OFFSET FLAT:??_7KIndexNode@@6B@ ; KIndexNode::`vftable'
	mov	DWORD PTR [esi+16], ebx
	mov	DWORD PTR [esi+20], ebx
	lea	ecx, DWORD PTR [esi+472]
	mov	DWORD PTR __$EHRec$[esp+32], ebx
	call	??0KMissleRes@@QAE@XZ			; KMissleRes::KMissleRes

; 136  : 	m_nMissleId = -1;
; 137  : 	m_nCollideOrVanishTime = 0;
; 138  : 	m_ulDamageInterval = 0;
; 139  : 	m_nTempParam1 = 0;
; 140  : 	m_nTempParam2 = 0;
; 141  : 	m_nFirstReclaimTime = 0;
; 142  : 	m_nEndReclaimTime = 0;
; 143  : 	m_btMissRate = 0;
; 144  : 	m_btHitCount = 0;
; 145  : #ifdef _SERVER
; 146  : 	m_pMagicAttribsData = NULL;
; 147  : 	m_ulNextCalDamageTime = 0;
; 148  : 	m_btRandomParam = 0;
; 149  : #else
; 150  : 	m_bFollowNpcWhenCollid = 1;
; 151  : 	m_bRemoving	= FALSE;
; 152  : 	m_btRedLum = m_btGreenLum = m_btBlueLum = 0xff;
; 153  : 	m_usLightRadius = 50;
; 154  : #endif
; 155  : }

	mov	ecx, DWORD PTR __$EHRec$[esp+24]
	mov	eax, 255				; 000000ffH
	mov	DWORD PTR [esi+464], eax
	mov	DWORD PTR [esi+460], eax
	mov	DWORD PTR [esi+456], eax
	mov	DWORD PTR [esi], OFFSET FLAT:??_7KMissle@@6B@ ; KMissle::`vftable'
	mov	DWORD PTR [esi+356], -1
	mov	DWORD PTR [esi+212], ebx
	mov	DWORD PTR [esi+196], ebx
	mov	DWORD PTR [esi+412], ebx
	mov	DWORD PTR [esi+416], ebx
	mov	DWORD PTR [esi+404], ebx
	mov	DWORD PTR [esi+408], ebx
	mov	BYTE PTR [esi+440], bl
	mov	BYTE PTR [esi+441], bl
	mov	DWORD PTR [esi+452], 1
	mov	DWORD PTR [esi+68], ebx
	mov	WORD PTR [esi+468], 50			; 00000032H
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L105920:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1KIndexNode@@UAE@XZ			; KIndexNode::~KIndexNode
$L105934:
	mov	eax, OFFSET FLAT:$T105933
	jmp	___CxxFrameHandler
text$x	ENDS
??0KMissle@@QAE@XZ ENDP					; KMissle::KMissle
EXTRN	??3@YAXPAX@Z:NEAR				; operator delete
;	COMDAT ??_GKMissle@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GKMissle@@UAEPAXI@Z PROC NEAR			; KMissle::`scalar deleting destructor', COMDAT
	push	esi
	mov	esi, ecx
	call	??1KMissle@@UAE@XZ			; KMissle::~KMissle
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L105941
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L105941:
	mov	eax, esi
	pop	esi
	ret	4
??_GKMissle@@UAEPAXI@Z ENDP				; KMissle::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?Release@KMissle@@AAEXXZ			; KMissle::Release
EXTRN	?RemoveObject@KScenePlaceC@@QAEXIHAAI@Z:NEAR	; KScenePlaceC::RemoveObject
EXTRN	?g_ScenePlace@@3VKScenePlaceC@@A:BYTE		; g_ScenePlace
EXTRN	?Clear@KMissleRes@@QAEXXZ:NEAR			; KMissleRes::Clear
;	COMDAT ?Release@KMissle@@AAEXXZ
_TEXT	SEGMENT
?Release@KMissle@@AAEXXZ PROC NEAR			; KMissle::Release, COMDAT

; 158  : {

	push	esi
	mov	esi, ecx

; 159  : #ifndef _SERVER	
; 160  : 	g_ScenePlace.RemoveObject(CGOG_MISSLE, m_nMissleId, m_SceneID);

	mov	ecx, DWORD PTR [esi+356]
	lea	eax, DWORD PTR [esi+2940]
	push	eax
	push	ecx
	push	9
	mov	ecx, OFFSET FLAT:?g_ScenePlace@@3VKScenePlaceC@@A
	call	?RemoveObject@KScenePlaceC@@QAEXIHAAI@Z	; KScenePlaceC::RemoveObject

; 161  : 	m_MissleRes.Clear();

	lea	ecx, DWORD PTR [esi+472]
	call	?Clear@KMissleRes@@QAEXXZ		; KMissleRes::Clear

; 162  : 	m_nMissleId = -1;
; 163  : 	m_nFollowNpcIdx = 0;

	xor	eax, eax
	mov	DWORD PTR [esi+356], -1
	mov	DWORD PTR [esi+324], eax

; 164  : 	m_nLastDoCollisionIdx = 0; //fix skills con lon dao by kinnox khong mat hinh anh;

	mov	DWORD PTR [esi+444], eax
	pop	esi

; 165  : #endif
; 166  : #ifdef _SERVER
; 167  : 	if (m_pMagicAttribsData)
; 168  : 		if (m_pMagicAttribsData->DelRef() == 0)
; 169  : 			delete m_pMagicAttribsData;
; 170  : 		m_pMagicAttribsData = NULL;
; 171  : #endif
; 172  : }

	ret	0
?Release@KMissle@@AAEXXZ ENDP				; KMissle::Release
_TEXT	ENDS
PUBLIC	??_7KNode@@6B@					; KNode::`vftable'
PUBLIC	??_GKNode@@UAEPAXI@Z				; KNode::`scalar deleting destructor'
PUBLIC	??_EKNode@@UAEPAXI@Z				; KNode::`vector deleting destructor'
EXTRN	??1KMissleRes@@QAE@XZ:NEAR			; KMissleRes::~KMissleRes
;	COMDAT ??_7KNode@@6B@
; File ..\engine\src\KNode.h
CONST	SEGMENT
??_7KNode@@6B@ DD FLAT:??_EKNode@@UAEPAXI@Z		; KNode::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T105961 DD	019930520H
	DD	01H
	DD	FLAT:$T105963
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T105963 DD	0ffffffffH
	DD	FLAT:$L105948
xdata$x	ENDS
;	COMDAT ??1KMissle@@UAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12
_this$ = -16
??1KMissle@@UAE@XZ PROC NEAR				; KMissle::~KMissle, COMDAT

; 175  : {

	push	-1
	push	$L105962
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[esp+20], esi
	mov	DWORD PTR [esi], OFFSET FLAT:??_7KMissle@@6B@ ; KMissle::`vftable'

; 176  : 	
; 177  : }

	lea	ecx, DWORD PTR [esi+472]
	mov	DWORD PTR __$EHRec$[esp+28], 0
	call	??1KMissleRes@@QAE@XZ			; KMissleRes::~KMissleRes
	mov	ecx, DWORD PTR __$EHRec$[esp+20]
	mov	DWORD PTR [esi+4], OFFSET FLAT:??_7KNode@@6B@ ; KNode::`vftable'
	pop	esi
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L105948:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1KIndexNode@@UAE@XZ			; KIndexNode::~KIndexNode
$L105962:
	mov	eax, OFFSET FLAT:$T105961
	jmp	___CxxFrameHandler
text$x	ENDS
??1KMissle@@UAE@XZ ENDP					; KMissle::~KMissle
;	COMDAT ??_GKNode@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GKNode@@UAEPAXI@Z PROC NEAR				; KNode::`scalar deleting destructor', COMDAT
	mov	al, BYTE PTR ___flags$[esp-4]
	push	esi
	mov	esi, ecx
	test	al, 1
	mov	DWORD PTR [esi], OFFSET FLAT:??_7KNode@@6B@ ; KNode::`vftable'
	je	SHORT $L105972
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L105972:
	mov	eax, esi
	pop	esi
	ret	4
??_GKNode@@UAEPAXI@Z ENDP				; KNode::`scalar deleting destructor'
_TEXT	ENDS
PUBLIC	?GetInfoFromTabFile@KMissle@@QAEHH@Z		; KMissle::GetInfoFromTabFile
PUBLIC	?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z ; KMissle::GetInfoFromTabFile
EXTRN	?g_MisslesSetting@@3VKTabFile@@A:BYTE		; g_MisslesSetting
;	COMDAT ?GetInfoFromTabFile@KMissle@@QAEHH@Z
_TEXT	SEGMENT
_nMissleId$ = 8
?GetInfoFromTabFile@KMissle@@QAEHH@Z PROC NEAR		; KMissle::GetInfoFromTabFile, COMDAT

; 188  : 	if (nMissleId <= 0 ) return FALSE;

	mov	eax, DWORD PTR _nMissleId$[esp-4]
	test	eax, eax
	jg	SHORT $L100918
	xor	eax, eax

; 191  : }

	ret	4
$L100918:

; 189  : 	KITabFile * pITabFile = &g_MisslesSetting;
; 190  : 	return GetInfoFromTabFile(pITabFile, nMissleId);

	push	eax
	push	OFFSET FLAT:?g_MisslesSetting@@3VKTabFile@@A ; g_MisslesSetting
	call	?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z ; KMissle::GetInfoFromTabFile

; 191  : }

	ret	4
?GetInfoFromTabFile@KMissle@@QAEHH@Z ENDP		; KMissle::GetInfoFromTabFile
_TEXT	ENDS
PUBLIC	??_C@_0L@MDID@MissleName?$AA@			; `string'
PUBLIC	??_C@_0N@IMPH@MissleHeight?$AA@			; `string'
PUBLIC	??_C@_08CLHE@LifeTime?$AA@			; `string'
PUBLIC	??_C@_05PDDA@Speed?$AA@				; `string'
PUBLIC	??_C@_0O@CEMO@ResponseSkill?$AA@		; `string'
PUBLIC	??_C@_0M@IPHD@CollidRange?$AA@			; `string'
PUBLIC	??_C@_09LLHA@ColVanish?$AA@			; `string'
PUBLIC	??_C@_0N@MOFP@CanColFriend?$AA@			; `string'
PUBLIC	??_C@_07ICPB@CanSlow?$AA@			; `string'
PUBLIC	??_C@_0L@DOMN@IsRangeDmg?$AA@			; `string'
PUBLIC	??_C@_08EKOK@DmgRange?$AA@			; `string'
PUBLIC	??_C@_08MKEC@MoveKind?$AA@			; `string'
PUBLIC	??_C@_0L@ICBE@FollowKind?$AA@			; `string'
PUBLIC	??_C@_04LIGI@Zacc?$AA@				; `string'
PUBLIC	??_C@_06EDNA@Zspeed?$AA@			; `string'
PUBLIC	??_C@_06DMFP@Param1?$AA@			; `string'
PUBLIC	??_C@_06MDOG@Param2?$AA@			; `string'
PUBLIC	??_C@_06GJHB@Param3?$AA@			; `string'
PUBLIC	??_C@_0M@CDCB@AutoExplode?$AA@			; `string'
PUBLIC	??_C@_0M@MLLA@DmgInterval?$AA@			; `string'
PUBLIC	??_C@_06PIMC@RedLum?$AA@			; `string'
PUBLIC	??_C@_08KOFB@GreenLum?$AA@			; `string'
PUBLIC	??_C@_07BJEB@BlueLum?$AA@			; `string'
PUBLIC	??_C@_0M@HJOL@LightRadius?$AA@			; `string'
PUBLIC	??_C@_09PDKK@MultiShow?$AA@			; `string'
PUBLIC	??_C@_0L@EKAK@AnimFile?$CFd?$AA@		; `string'
PUBLIC	??_C@_09CDAF@SndFile?$CFd?$AA@			; `string'
PUBLIC	??_C@_0P@EKPH@AnimFileInfo?$CFd?$AA@		; `string'
PUBLIC	??_C@_0M@LCCH@AnimFileB?$CFd?$AA@		; `string'
PUBLIC	??_C@_0L@HHEO@SndFileB?$CFd?$AA@		; `string'
PUBLIC	??_C@_0BA@BPCH@AnimFileInfoB?$CFd?$AA@		; `string'
PUBLIC	??_C@_08OBCD@LoopPlay?$AA@			; `string'
PUBLIC	??_C@_07MAEH@SubLoop?$AA@			; `string'
PUBLIC	??_C@_08CAJJ@SubStart?$AA@			; `string'
PUBLIC	??_C@_07CKM@SubStop?$AA@			; `string'
PUBLIC	??_C@_0BA@PAFJ@ColFollowTarget?$AA@		; `string'
PUBLIC	??_C@_00A@?$AA@					; `string'
EXTRN	__imp_?KSG_StringGetInt@@YAHPAPBDH@Z:NEAR
EXTRN	__imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z:NEAR
EXTRN	__imp__sprintf:NEAR
;	COMDAT ??_C@_00A@?$AA@
; File D:\HuyenThietKiemNguyenThuy\SwordOnline\Sources\Core\Src\KMissle.cpp
_BSS	SEGMENT
??_C@_00A@?$AA@ DB 01H DUP (?)				; `string'
_BSS	ENDS
;	COMDAT ??_C@_0L@MDID@MissleName?$AA@
_DATA	SEGMENT
??_C@_0L@MDID@MissleName?$AA@ DB 'MissleName', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@IMPH@MissleHeight?$AA@
_DATA	SEGMENT
??_C@_0N@IMPH@MissleHeight?$AA@ DB 'MissleHeight', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08CLHE@LifeTime?$AA@
_DATA	SEGMENT
??_C@_08CLHE@LifeTime?$AA@ DB 'LifeTime', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_05PDDA@Speed?$AA@
_DATA	SEGMENT
??_C@_05PDDA@Speed?$AA@ DB 'Speed', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_0O@CEMO@ResponseSkill?$AA@
_DATA	SEGMENT
??_C@_0O@CEMO@ResponseSkill?$AA@ DB 'ResponseSkill', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@IPHD@CollidRange?$AA@
_DATA	SEGMENT
??_C@_0M@IPHD@CollidRange?$AA@ DB 'CollidRange', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09LLHA@ColVanish?$AA@
_DATA	SEGMENT
??_C@_09LLHA@ColVanish?$AA@ DB 'ColVanish', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0N@MOFP@CanColFriend?$AA@
_DATA	SEGMENT
??_C@_0N@MOFP@CanColFriend?$AA@ DB 'CanColFriend', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_07ICPB@CanSlow?$AA@
_DATA	SEGMENT
??_C@_07ICPB@CanSlow?$AA@ DB 'CanSlow', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@DOMN@IsRangeDmg?$AA@
_DATA	SEGMENT
??_C@_0L@DOMN@IsRangeDmg?$AA@ DB 'IsRangeDmg', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_08EKOK@DmgRange?$AA@
_DATA	SEGMENT
??_C@_08EKOK@DmgRange?$AA@ DB 'DmgRange', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08MKEC@MoveKind?$AA@
_DATA	SEGMENT
??_C@_08MKEC@MoveKind?$AA@ DB 'MoveKind', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@ICBE@FollowKind?$AA@
_DATA	SEGMENT
??_C@_0L@ICBE@FollowKind?$AA@ DB 'FollowKind', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_04LIGI@Zacc?$AA@
_DATA	SEGMENT
??_C@_04LIGI@Zacc?$AA@ DB 'Zacc', 00H			; `string'
_DATA	ENDS
;	COMDAT ??_C@_06EDNA@Zspeed?$AA@
_DATA	SEGMENT
??_C@_06EDNA@Zspeed?$AA@ DB 'Zspeed', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06DMFP@Param1?$AA@
_DATA	SEGMENT
??_C@_06DMFP@Param1?$AA@ DB 'Param1', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06MDOG@Param2?$AA@
_DATA	SEGMENT
??_C@_06MDOG@Param2?$AA@ DB 'Param2', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_06GJHB@Param3?$AA@
_DATA	SEGMENT
??_C@_06GJHB@Param3?$AA@ DB 'Param3', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@CDCB@AutoExplode?$AA@
_DATA	SEGMENT
??_C@_0M@CDCB@AutoExplode?$AA@ DB 'AutoExplode', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@MLLA@DmgInterval?$AA@
_DATA	SEGMENT
??_C@_0M@MLLA@DmgInterval?$AA@ DB 'DmgInterval', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_06PIMC@RedLum?$AA@
_DATA	SEGMENT
??_C@_06PIMC@RedLum?$AA@ DB 'RedLum', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08KOFB@GreenLum?$AA@
_DATA	SEGMENT
??_C@_08KOFB@GreenLum?$AA@ DB 'GreenLum', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07BJEB@BlueLum?$AA@
_DATA	SEGMENT
??_C@_07BJEB@BlueLum?$AA@ DB 'BlueLum', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@HJOL@LightRadius?$AA@
_DATA	SEGMENT
??_C@_0M@HJOL@LightRadius?$AA@ DB 'LightRadius', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09PDKK@MultiShow?$AA@
_DATA	SEGMENT
??_C@_09PDKK@MultiShow?$AA@ DB 'MultiShow', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@EKAK@AnimFile?$CFd?$AA@
_DATA	SEGMENT
??_C@_0L@EKAK@AnimFile?$CFd?$AA@ DB 'AnimFile%d', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_09CDAF@SndFile?$CFd?$AA@
_DATA	SEGMENT
??_C@_09CDAF@SndFile?$CFd?$AA@ DB 'SndFile%d', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0P@EKPH@AnimFileInfo?$CFd?$AA@
_DATA	SEGMENT
??_C@_0P@EKPH@AnimFileInfo?$CFd?$AA@ DB 'AnimFileInfo%d', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_0M@LCCH@AnimFileB?$CFd?$AA@
_DATA	SEGMENT
??_C@_0M@LCCH@AnimFileB?$CFd?$AA@ DB 'AnimFileB%d', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0L@HHEO@SndFileB?$CFd?$AA@
_DATA	SEGMENT
??_C@_0L@HHEO@SndFileB?$CFd?$AA@ DB 'SndFileB%d', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@BPCH@AnimFileInfoB?$CFd?$AA@
_DATA	SEGMENT
??_C@_0BA@BPCH@AnimFileInfoB?$CFd?$AA@ DB 'AnimFileInfoB%d', 00H ; `string'
_DATA	ENDS
;	COMDAT ??_C@_08OBCD@LoopPlay?$AA@
_DATA	SEGMENT
??_C@_08OBCD@LoopPlay?$AA@ DB 'LoopPlay', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07MAEH@SubLoop?$AA@
_DATA	SEGMENT
??_C@_07MAEH@SubLoop?$AA@ DB 'SubLoop', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_08CAJJ@SubStart?$AA@
_DATA	SEGMENT
??_C@_08CAJJ@SubStart?$AA@ DB 'SubStart', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_07CKM@SubStop?$AA@
_DATA	SEGMENT
??_C@_07CKM@SubStop?$AA@ DB 'SubStop', 00H		; `string'
_DATA	ENDS
;	COMDAT ??_C@_0BA@PAFJ@ColFollowTarget?$AA@
_DATA	SEGMENT
??_C@_0BA@PAFJ@ColFollowTarget?$AA@ DB 'ColFollowTarget', 00H ; `string'
_DATA	ENDS
;	COMDAT ?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z
_TEXT	SEGMENT
_pMisslesSetting$ = 8
_nMissleId$ = 12
_this$ = -336
_nHeightOld$ = -332
_bAutoExplode$ = -344
_AnimFileCol$ = -264
_SndFileCol$ = -328
_AnimFileInfoCol$ = -200
_szAnimFileInfo$ = -100
_pcszTemp$ = -348
_nLightRadius$ = -340
?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z PROC NEAR ; KMissle::GetInfoFromTabFile, COMDAT

; 194  : {

	sub	esp, 348				; 0000015cH
	push	ebx
	push	ebp
	push	edi

; 195  : 	if (nMissleId <= 0 ) return FALSE;

	mov	edi, DWORD PTR _nMissleId$[esp+356]
	xor	ebp, ebp
	mov	ebx, ecx
	cmp	edi, ebp
	mov	DWORD PTR _this$[esp+360], ebx
	jg	SHORT $L100925
	pop	edi
	pop	ebp
	xor	eax, eax
	pop	ebx

; 305  : }

	add	esp, 348				; 0000015cH
	ret	8
$L100925:
	push	esi

; 196  : 	m_nMissleId		= nMissleId;
; 197  : 	int nRow = nMissleId;
; 198  : 	
; 199  : 	pMisslesSetting->GetString(nRow, "MissleName",		   "", m_szMissleName,30, TRUE);

	mov	esi, DWORD PTR _pMisslesSetting$[esp+360]
	push	1
	lea	ecx, DWORD PTR [ebx+24]
	push	30					; 0000001eH
	push	ecx
	mov	DWORD PTR [ebx+356], edi
	mov	eax, DWORD PTR [esi]
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	OFFSET FLAT:??_C@_0L@MDID@MissleName?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [eax+36]

; 200  : 	
; 201  : 	int nHeightOld ;
; 202  : 	pMisslesSetting->GetInteger(nRow, "MissleHeight",		0, &nHeightOld, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _nHeightOld$[esp+364]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_0N@IMPH@MissleHeight?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 203  : 	m_nHeight = nHeightOld << 10;

	mov	ecx, DWORD PTR _nHeightOld$[esp+364]

; 204  : 	
; 205  : 	pMisslesSetting->GetInteger(nRow, "LifeTime",			0, &m_nLifeTime, TRUE);

	lea	eax, DWORD PTR [ebx+92]
	shl	ecx, 10					; 0000000aH
	push	1
	push	eax
	mov	DWORD PTR [ebx+84], ecx
	mov	edx, DWORD PTR [esi]
	push	ebp
	push	OFFSET FLAT:??_C@_08CLHE@LifeTime?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 206  : 	pMisslesSetting->GetInteger(nRow, "Speed",				0, &m_nSpeed, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+96]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_05PDDA@Speed?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 207  : 	pMisslesSetting->GetInteger(nRow, "ResponseSkill",		0, &m_nSkillId, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+100]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_0O@CEMO@ResponseSkill?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 208  : 	pMisslesSetting->GetInteger(nRow, "CollidRange",		0, &m_nCollideRange, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+144]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_0M@IPHD@CollidRange?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 209  : 	pMisslesSetting->GetInteger(nRow, "ColVanish",			0, &m_bCollideVanish, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+152]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_09LLHA@ColVanish?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 210  : 	pMisslesSetting->GetInteger(nRow, "CanColFriend",		0, &m_bCollideFriend, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+156]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_0N@MOFP@CanColFriend?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 211  : 	pMisslesSetting->GetInteger(nRow, "CanSlow",			0, &m_bCanSlow, TRUE);

	mov	edx, DWORD PTR [esi]
	push	1
	lea	eax, DWORD PTR [ebx+160]
	mov	ecx, esi
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_07ICPB@CanSlow?$AA@	; `string'
	push	edi
	call	DWORD PTR [edx+48]

; 212  : 	pMisslesSetting->GetInteger(nRow, "IsRangeDmg",		0, &m_bRangeDamage, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+104]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_0L@DOMN@IsRangeDmg?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 213  : 	pMisslesSetting->GetInteger(nRow, "DmgRange",			0, &m_nDamageRange, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+148]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_08EKOK@DmgRange?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 214  : 	pMisslesSetting->GetInteger(nRow, "MoveKind",			0, (int*)&m_eMoveKind, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+76]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_08MKEC@MoveKind?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 215  : 	pMisslesSetting->GetInteger(nRow, "FollowKind",		0, (int*)&m_eFollowKind, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+80]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_0L@ICBE@FollowKind?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 216  : 	pMisslesSetting->GetInteger(nRow, "Zacc",				0,(int*)&m_nZAcceleration, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+348]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_04LIGI@Zacc?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 217  : 	pMisslesSetting->GetInteger(nRow, "Zspeed",				0,(int*)&m_nHeightSpeed, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+88]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_06EDNA@Zspeed?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 218  : 	pMisslesSetting->GetInteger(nRow, "Param1",			0, &m_nParam1, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+392]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_06DMFP@Param1?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 219  : 	pMisslesSetting->GetInteger(nRow, "Param2",			0, &m_nParam2, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+396]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_06MDOG@Param2?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 220  : 	pMisslesSetting->GetInteger(nRow, "Param3",			0, &m_nParam3, TRUE);

	mov	edx, DWORD PTR [esi]
	push	1
	lea	eax, DWORD PTR [ebx+400]
	mov	ecx, esi
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_06GJHB@Param3?$AA@	; `string'
	push	edi
	call	DWORD PTR [edx+48]

; 221  : 	
; 222  : 	BOOL bAutoExplode = 0;
; 223  : 	pMisslesSetting->GetInteger(nRow, "AutoExplode",	0, (int*)&bAutoExplode, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _bAutoExplode$[esp+364]
	push	1
	push	eax
	push	ebp
	push	OFFSET FLAT:??_C@_0M@CDCB@AutoExplode?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _bAutoExplode$[esp+384], ebp
	call	DWORD PTR [edx+48]

; 224  : 	m_bAutoExplode = bAutoExplode;

	mov	ecx, DWORD PTR _bAutoExplode$[esp+364]

; 225  : 	
; 226  : 	pMisslesSetting->GetInteger(nRow, "DmgInterval",	0, (int*)&m_ulDamageInterval, TRUE);

	lea	eax, DWORD PTR [ebx+196]
	push	1
	push	eax
	mov	DWORD PTR [ebx+112], ecx
	mov	edx, DWORD PTR [esi]
	push	ebp
	push	OFFSET FLAT:??_C@_0M@MLLA@DmgInterval?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 227  : 	
; 228  : #ifndef _SERVER	
; 229  : 	char AnimFileCol[64];
; 230  : 	char SndFileCol[64];
; 231  : 	char AnimFileInfoCol[100];
; 232  : 	char szAnimFileInfo[100];
; 233  : 
; 234  :     const char *pcszTemp = NULL;
; 235  : 	
; 236  : 	pMisslesSetting->GetInteger(nRow, "RedLum",	    255, (int*)&m_btRedLum, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+456]
	push	1
	push	eax
	push	255					; 000000ffH
	push	OFFSET FLAT:??_C@_06PIMC@RedLum?$AA@	; `string'
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _pcszTemp$[esp+384], ebp
	call	DWORD PTR [edx+48]

; 237  : 	pMisslesSetting->GetInteger(nRow, "GreenLum",	255, (int*)&m_btGreenLum, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+460]
	push	1
	push	eax
	push	255					; 000000ffH
	push	OFFSET FLAT:??_C@_08KOFB@GreenLum?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 238  : 	pMisslesSetting->GetInteger(nRow, "BlueLum",	255, (int*)&m_btBlueLum, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+464]
	push	1
	push	eax
	push	255					; 000000ffH
	push	OFFSET FLAT:??_C@_07BJEB@BlueLum?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 239  : 	
; 240  : 	int nLightRadius = 0;
; 241  : 	pMisslesSetting->GetInteger(nRow, "LightRadius", 50, (int*)&nLightRadius, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _nLightRadius$[esp+364]
	push	1
	push	eax
	push	50					; 00000032H
	push	OFFSET FLAT:??_C@_0M@HJOL@LightRadius?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	mov	DWORD PTR _nLightRadius$[esp+384], ebp
	call	DWORD PTR [edx+48]

; 242  : 	m_usLightRadius = nLightRadius;

	mov	cx, WORD PTR _nLightRadius$[esp+364]

; 243  : 	
; 244  : 	pMisslesSetting->GetInteger(nRow, "MultiShow",		0, &m_bMultiShow, TRUE);

	lea	eax, DWORD PTR [ebx+448]
	push	1
	push	eax
	mov	WORD PTR [ebx+468], cx
	mov	edx, DWORD PTR [esi]
	push	ebp
	push	OFFSET FLAT:??_C@_09PDKK@MultiShow?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]
	mov	ebp, 1
	add	ebx, 616				; 00000268H
$L100971:

; 245  : 	for (int i  = 0; i < MAX_MISSLE_STATUS; i++)
; 246  : 	{
; 247  : 		sprintf(AnimFileCol, "AnimFile%d", i + 1);

	push	ebp
	lea	ecx, DWORD PTR _AnimFileCol$[esp+368]
	push	OFFSET FLAT:??_C@_0L@EKAK@AnimFile?$CFd?$AA@ ; `string'
	push	ecx
	call	DWORD PTR __imp__sprintf

; 248  : 		sprintf(SndFileCol,  "SndFile%d", i + 1);

	push	ebp
	lea	edx, DWORD PTR _SndFileCol$[esp+380]
	push	OFFSET FLAT:??_C@_09CDAF@SndFile?$CFd?$AA@ ; `string'
	push	edx
	call	DWORD PTR __imp__sprintf

; 249  : 		sprintf(AnimFileInfoCol, "AnimFileInfo%d", i + 1);

	push	ebp
	lea	eax, DWORD PTR _AnimFileInfoCol$[esp+392]
	push	OFFSET FLAT:??_C@_0P@EKPH@AnimFileInfo?$CFd?$AA@ ; `string'
	push	eax
	call	DWORD PTR __imp__sprintf

; 250  : 		
; 251  : 		pMisslesSetting->GetString(nRow, AnimFileCol,			"", m_MissleRes.m_MissleRes[i].AnimFileName, 64, TRUE);

	mov	edx, DWORD PTR [esi]
	add	esp, 36					; 00000024H
	lea	eax, DWORD PTR [ebx-112]
	lea	ecx, DWORD PTR _AnimFileCol$[esp+364]
	push	1
	push	64					; 00000040H
	push	eax
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	ecx
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+36]

; 252  : 		pMisslesSetting->GetString(nRow, SndFileCol,			"", m_MissleRes.m_MissleRes[i].SndFileName, 64, TRUE);

	mov	edx, DWORD PTR [esi]
	push	1
	push	64					; 00000040H
	push	ebx
	lea	eax, DWORD PTR _SndFileCol$[esp+376]
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	eax
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+36]

; 253  : 		pMisslesSetting->GetString(nRow, AnimFileInfoCol,		"", szAnimFileInfo, 100, TRUE);

	mov	edx, DWORD PTR [esi]
	push	1
	lea	eax, DWORD PTR _szAnimFileInfo$[esp+368]
	push	100					; 00000064H
	push	eax
	lea	ecx, DWORD PTR _AnimFileInfoCol$[esp+376]
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	ecx
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+36]

; 254  : 		
; 255  : 		//m_MissleRes.m_MissleRes[i].nInterval = 1;
; 256  : 		//m_MissleRes.m_MissleRes[i].nDir = 16;
; 257  : 		//m_MissleRes.m_MissleRes[i].nTotalFrame = 100;
; 258  : 
; 259  :         pcszTemp = szAnimFileInfo;
; 260  :         m_MissleRes.m_MissleRes[i].nTotalFrame = KSG_StringGetInt(&pcszTemp, 100);

	lea	eax, DWORD PTR _pcszTemp$[esp+364]
	lea	edx, DWORD PTR _szAnimFileInfo$[esp+364]
	push	100					; 00000064H
	push	eax
	mov	DWORD PTR _pcszTemp$[esp+372], edx
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z

; 261  :         KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	ecx, DWORD PTR _pcszTemp$[esp+372]
	push	44					; 0000002cH
	push	ecx
	mov	DWORD PTR [ebx-12], eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 262  :         m_MissleRes.m_MissleRes[i].nDir = KSG_StringGetInt(&pcszTemp, 16);

	lea	edx, DWORD PTR _pcszTemp$[esp+380]
	push	16					; 00000010H
	push	edx
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z
	mov	DWORD PTR [ebx-4], eax

; 263  :         KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	eax, DWORD PTR _pcszTemp$[esp+388]
	push	44					; 0000002cH
	push	eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 264  :         m_MissleRes.m_MissleRes[i].nInterval = KSG_StringGetInt(&pcszTemp, 1);

	lea	ecx, DWORD PTR _pcszTemp$[esp+396]
	push	1
	push	ecx
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z

; 265  : 		//sscanf(szAnimFileInfo, "%d,%d,%d", 
; 266  : 		//	&m_MissleRes.m_MissleRes[i].nTotalFrame,
; 267  : 		//	&m_MissleRes.m_MissleRes[i].nDir,
; 268  : 		//	&m_MissleRes.m_MissleRes[i].nInterval
; 269  :         //);
; 270  : 
; 271  : 		
; 272  : 		sprintf(AnimFileCol, "AnimFileB%d", i + 1);

	push	ebp
	lea	edx, DWORD PTR _AnimFileCol$[esp+408]
	push	OFFSET FLAT:??_C@_0M@LCCH@AnimFileB?$CFd?$AA@ ; `string'
	push	edx
	mov	DWORD PTR [ebx-8], eax
	call	DWORD PTR __imp__sprintf

; 273  : 		sprintf(SndFileCol,  "SndFileB%d", i + 1);

	push	ebp
	push	OFFSET FLAT:??_C@_0L@HHEO@SndFileB?$CFd?$AA@ ; `string'
	lea	eax, DWORD PTR _SndFileCol$[esp+424]
	push	eax
	call	DWORD PTR __imp__sprintf
	add	esp, 64					; 00000040H

; 274  : 		sprintf(AnimFileInfoCol, "AnimFileInfoB%d", i + 1);

	lea	ecx, DWORD PTR _AnimFileInfoCol$[esp+364]
	push	ebp
	push	OFFSET FLAT:??_C@_0BA@BPCH@AnimFileInfoB?$CFd?$AA@ ; `string'
	push	ecx
	call	DWORD PTR __imp__sprintf

; 275  : 		
; 276  : 		pMisslesSetting->GetString(nRow, AnimFileCol,			"", m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].AnimFileName, 64, TRUE);

	mov	edx, DWORD PTR [esi]
	add	esp, 12					; 0000000cH
	lea	eax, DWORD PTR [ebx+736]
	lea	ecx, DWORD PTR _AnimFileCol$[esp+364]
	push	1
	push	64					; 00000040H
	push	eax
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	ecx
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+36]

; 277  : 		pMisslesSetting->GetString(nRow, SndFileCol,			"", m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].SndFileName, 64, TRUE);

	mov	edx, DWORD PTR [esi]
	push	1
	lea	eax, DWORD PTR [ebx+848]
	push	64					; 00000040H
	push	eax
	lea	ecx, DWORD PTR _SndFileCol$[esp+376]
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	ecx
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+36]

; 278  : 		pMisslesSetting->GetString(nRow, AnimFileInfoCol,		"", szAnimFileInfo, 100, TRUE);

	mov	edx, DWORD PTR [esi]
	push	1
	lea	eax, DWORD PTR _szAnimFileInfo$[esp+368]
	push	100					; 00000064H
	push	eax
	lea	ecx, DWORD PTR _AnimFileInfoCol$[esp+376]
	push	OFFSET FLAT:??_C@_00A@?$AA@		; `string'
	push	ecx
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+36]

; 279  : 		
; 280  : 		//m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nInterval = 1;
; 281  : 		//m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nDir = 16;
; 282  : 		//m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nTotalFrame = 100;
; 283  : 		
; 284  :         pcszTemp = szAnimFileInfo;
; 285  :         m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nTotalFrame = KSG_StringGetInt(&pcszTemp, 100);

	lea	eax, DWORD PTR _pcszTemp$[esp+364]
	lea	edx, DWORD PTR _szAnimFileInfo$[esp+364]
	push	100					; 00000064H
	push	eax
	mov	DWORD PTR _pcszTemp$[esp+372], edx
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z

; 286  :         KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	ecx, DWORD PTR _pcszTemp$[esp+372]
	push	44					; 0000002cH
	push	ecx
	mov	DWORD PTR [ebx+836], eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 287  :         m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nDir = KSG_StringGetInt(&pcszTemp, 16);

	lea	edx, DWORD PTR _pcszTemp$[esp+380]
	push	16					; 00000010H
	push	edx
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z
	mov	DWORD PTR [ebx+844], eax

; 288  :         KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	eax, DWORD PTR _pcszTemp$[esp+388]
	push	44					; 0000002cH
	push	eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 289  :         m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nInterval = KSG_StringGetInt(&pcszTemp, 1);

	lea	ecx, DWORD PTR _pcszTemp$[esp+396]
	push	1
	push	ecx
	call	DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z
	add	esp, 40					; 00000028H
	inc	ebp
	mov	DWORD PTR [ebx+840], eax
	add	ebx, 212				; 000000d4H
	lea	edx, DWORD PTR [ebp-1]
	cmp	edx, 4
	jl	$L100971

; 290  : 
; 291  : 		//sscanf(szAnimFileInfo, "%d,%d,%d", 
; 292  : 		//	&m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nTotalFrame,
; 293  : 		//	&m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nDir,
; 294  : 		//	&m_MissleRes.m_MissleRes[i + MAX_MISSLE_STATUS].nInterval
; 295  :         //);
; 296  : 		
; 297  : 	}
; 298  : 	pMisslesSetting->GetInteger(nRow, "LoopPlay",			0, &m_MissleRes.m_bLoopAnim, TRUE);

	mov	ebx, DWORD PTR _this$[esp+364]
	mov	eax, DWORD PTR [esi]
	push	1
	lea	ecx, DWORD PTR [ebx+500]
	push	ecx
	push	0
	push	OFFSET FLAT:??_C@_08OBCD@LoopPlay?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [eax+48]

; 299  : 	pMisslesSetting->GetInteger(nRow, "SubLoop",		0, &m_MissleRes.m_bSubLoop, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+2252]
	push	1
	push	eax
	push	0
	push	OFFSET FLAT:??_C@_07MAEH@SubLoop?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 300  : 	pMisslesSetting->GetInteger(nRow, "SubStart",		0, &m_MissleRes.m_nSubStart, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+2256]
	push	1
	push	eax
	push	0
	push	OFFSET FLAT:??_C@_08CAJJ@SubStart?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 301  : 	pMisslesSetting->GetInteger(nRow, "SubStop",		0, &m_MissleRes.m_nSubStop, TRUE);

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR [ebx+2260]
	push	1
	push	eax
	push	0
	push	OFFSET FLAT:??_C@_07CKM@SubStop?$AA@	; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]

; 302  : 	pMisslesSetting->GetInteger(nRow, "ColFollowTarget",0, (int *)&m_bFollowNpcWhenCollid, TRUE);

	mov	edx, DWORD PTR [esi]
	add	ebx, 452				; 000001c4H
	push	1
	push	ebx
	push	0
	push	OFFSET FLAT:??_C@_0BA@PAFJ@ColFollowTarget?$AA@ ; `string'
	push	edi
	mov	ecx, esi
	call	DWORD PTR [edx+48]
	pop	esi
	pop	edi
	pop	ebp

; 303  : #endif
; 304  : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 305  : }

	add	esp, 348				; 0000015cH
	ret	8
?GetInfoFromTabFile@KMissle@@QAEHPAVKITabFile@@H@Z ENDP	; KMissle::GetInfoFromTabFile
_TEXT	ENDS
;	COMDAT ??_GKIndexNode@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GKIndexNode@@UAEPAXI@Z PROC NEAR			; KIndexNode::`scalar deleting destructor', COMDAT
	push	esi
	mov	esi, ecx
	call	??1KIndexNode@@UAE@XZ			; KIndexNode::~KIndexNode
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L105985
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L105985:
	mov	eax, esi
	pop	esi
	ret	4
??_GKIndexNode@@UAEPAXI@Z ENDP				; KIndexNode::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1KIndexNode@@UAE@XZ
_TEXT	SEGMENT
??1KIndexNode@@UAE@XZ PROC NEAR				; KIndexNode::~KIndexNode, COMDAT
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7KNode@@6B@ ; KNode::`vftable'
	ret	0
??1KIndexNode@@UAE@XZ ENDP				; KIndexNode::~KIndexNode
_TEXT	ENDS
PUBLIC	?Init@KMissle@@AAEHHHHHH@Z			; KMissle::Init
EXTRN	?Init@KMissleRes@@QAEHXZ:NEAR			; KMissleRes::Init
;	COMDAT ?Init@KMissle@@AAEHHHHHH@Z
_TEXT	SEGMENT
?Init@KMissle@@AAEHHHHHH@Z PROC NEAR			; KMissle::Init, COMDAT

; 309  : #ifndef _SERVER
; 310  : 	m_MissleRes.Init();

	add	ecx, 472				; 000001d8H
	call	?Init@KMissleRes@@QAEHXZ		; KMissleRes::Init

; 311  : #endif
; 312  : 	return	TRUE;

	mov	eax, 1

; 313  : }

	ret	20					; 00000014H
?Init@KMissle@@AAEHHHHHH@Z ENDP				; KMissle::Init
_TEXT	ENDS
PUBLIC	?OnVanish@KMissle@@AAEXXZ			; KMissle::OnVanish
PUBLIC	?OnCollision@KMissle@@AAEXXZ			; KMissle::OnCollision
PUBLIC	?OnFly@KMissle@@AAEXXZ				; KMissle::OnFly
PUBLIC	?OnWait@KMissle@@AAEXXZ				; KMissle::OnWait
PUBLIC	?DoFly@KMissle@@AAEXXZ				; KMissle::DoFly
PUBLIC	?PrePareFly@KMissle@@AAEHXZ			; KMissle::PrePareFly
PUBLIC	?DoVanish@KMissle@@AAEXXZ			; KMissle::DoVanish
PUBLIC	?ProcessCollision@KMissle@@AAEHXZ		; KMissle::ProcessCollision
PUBLIC	?Activate@KMissle@@QAEHXZ			; KMissle::Activate
EXTRN	?InstanceSkill@KSkillManager@@AAEPAVISkill@@KK@Z:NEAR ; KSkillManager::InstanceSkill
EXTRN	?g_SkillManager@@3VKSkillManager@@A:BYTE	; g_SkillManager
EXTRN	?MoveObject@KScenePlaceC@@QAEIIHHHHAAIH@Z:NEAR	; KScenePlaceC::MoveObject
EXTRN	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z:NEAR	; KSubWorld::Map2Mps
EXTRN	?SubWorld@@3PAVKSubWorld@@A:BYTE		; SubWorld
EXTRN	?Npc@@3PAVKNpc@@A:BYTE				; Npc
EXTRN	?PlaySoundA@KMissleRes@@QAEXHHHH@Z:NEAR		; KMissleRes::PlaySoundA
EXTRN	?FlyEvent@KSkill@@ABEXPAVKMissle@@@Z:NEAR	; KSkill::FlyEvent
EXTRN	?Collidsion@KSkill@@ABEXPAVKMissle@@@Z:NEAR	; KSkill::Collidsion
;	COMDAT ?Activate@KMissle@@QAEHXZ
_TEXT	SEGMENT
_nSrcX2$101016 = -4
_nSrcY2$101017 = -8
_nSrcX$101035 = -8
_nSrcY$101036 = -4
?Activate@KMissle@@QAEHXZ PROC NEAR			; KMissle::Activate, COMDAT

; 326  : {	

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 327  : 	if (m_nMissleId <= 0 || m_nRegionId < 0)

	mov	eax, DWORD PTR [esi+356]
	test	eax, eax
	jle	$L100998
	mov	eax, DWORD PTR [esi+364]
	test	eax, eax
	jl	$L100998

; 330  : 	}
; 331  : 	
; 332  : 	_ASSERT(m_nLauncher > 0);
; 333  : 	if (m_nLauncher <= 0)

	mov	ecx, DWORD PTR [esi+332]
	test	ecx, ecx

; 334  : 		return 0;

	jle	$L100998

; 335  : 	
; 336  : 	if (!Npc[m_nLauncher].IsMatch(m_dwLauncherId) || 
; 337  : 		Npc[m_nLauncher].m_SubWorldIndex != m_nSubWorldId || 
; 338  : 		Npc[m_nLauncher].m_RegionIndex < 0)

	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	mov	ecx, DWORD PTR [esi+336]
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	cmp	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax]
	jne	$L101002
	mov	edx, DWORD PTR [esi+360]
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2604]
	cmp	ecx, edx
	jne	$L101002
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2608]
	test	ecx, ecx
	jl	$L101002

; 341  : 		return 0;	
; 342  : 	}
; 343  : 	
; 344  : 	if (m_nFollowNpcIdx > 0)

	mov	ecx, DWORD PTR [esi+324]
	test	ecx, ecx
	jle	SHORT $L101004

; 345  : 	{
; 346  : 		if (!Npc[m_nFollowNpcIdx].IsMatch(m_dwFollowNpcID) || 
; 347  : 			Npc[m_nFollowNpcIdx].m_SubWorldIndex != m_nSubWorldId)

	lea	eax, DWORD PTR [ecx+ecx*2]
	push	ebx
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	mov	ecx, DWORD PTR [esi+328]
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	mov	ebx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax]
	cmp	ecx, ebx
	pop	ebx
	jne	SHORT $L101005
	cmp	DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2604], edx
	je	SHORT $L101004
$L101005:

; 348  : 		{
; 349  : 			m_nFollowNpcIdx = 0;

	mov	DWORD PTR [esi+324], 0
$L101004:

; 350  : 		}
; 351  : 	}
; 352  : 	
; 353  : 	eMissleStatus eLastStatus = m_eMissleStatus;
; 354  : 	
; 355  : 	if (
; 356  : 		m_nCurrentLife >= m_nLifeTime 
; 357  : 		&& m_eMissleStatus != MS_DoVanish 
; 358  : 		&& m_eMissleStatus != MS_DoCollision
; 359  : 		)

	mov	edx, DWORD PTR [esi+204]
	mov	eax, DWORD PTR [esi+92]
	cmp	edx, eax
	jl	SHORT $L101007
	mov	eax, DWORD PTR [esi+352]
	cmp	eax, 2
	je	SHORT $L101007
	cmp	eax, 3
	je	SHORT $L101007

; 360  : 	{
; 361  : 		if (m_bAutoExplode)

	mov	eax, DWORD PTR [esi+112]
	test	eax, eax
	je	SHORT $L101013

; 362  : 		{
; 363  : 			ProcessCollision();

	mov	ecx, esi
	call	?ProcessCollision@KMissle@@AAEHXZ	; KMissle::ProcessCollision

; 364  : 			if (m_bCollideEvent)	

	mov	eax, DWORD PTR [esi+188]
	test	eax, eax
	je	SHORT $L101013

; 365  : 			{
; 366  : 				_ASSERT(m_nSkillId < MAX_SKILL && m_nLevel < MAX_SKILLLEVEL);
; 367  : 				KSkill * pOrdinSkill = (KSkill *)g_SkillManager.GetSkill(m_nSkillId, m_nLevel);

	mov	eax, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [esi+320]
	cmp	eax, 2000				; 000007d0H
	jg	SHORT $L101013
	test	eax, eax
	jle	SHORT $L101013
	test	ecx, ecx
	jle	SHORT $L101013
	cmp	ecx, 64					; 00000040H
	jg	SHORT $L101013
	mov	edx, eax
	shl	edx, 6
	add	edx, ecx
	mov	edx, DWORD PTR ?g_SkillManager@@3VKSkillManager@@A[edx*4+31740]
	test	edx, edx
	je	SHORT $L106011
	mov	eax, edx
	jmp	SHORT $L106006
$L106011:
	push	ecx
	push	eax
	mov	ecx, OFFSET FLAT:?g_SkillManager@@3VKSkillManager@@A
	call	?InstanceSkill@KSkillManager@@AAEPAVISkill@@KK@Z ; KSkillManager::InstanceSkill
$L106006:

; 368  : 				if (pOrdinSkill)

	test	eax, eax
	je	SHORT $L101013

; 369  : 				{
; 370  : 					pOrdinSkill->Collidsion(this);

	push	esi
	mov	ecx, eax
	call	?Collidsion@KSkill@@ABEXPAVKMissle@@@Z	; KSkill::Collidsion
$L101013:

; 371  : 				}
; 372  : 			}
; 373  : 		}
; 374  : 		DoVanish();

	mov	ecx, esi
	call	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
$L101007:

; 375  : #ifdef _SERVER
; 376  : 		m_nCurrentLife ++;
; 377  : 		return 1;
; 378  : #endif
; 379  : 	}
; 380  : 	
; 381  : 	if (m_nCurrentLife == m_nStartLifeTime && m_eMissleStatus != MS_DoVanish)	

	mov	eax, DWORD PTR [esi+204]
	mov	ecx, DWORD PTR [esi+208]
	cmp	eax, ecx
	jne	$L101018
	cmp	DWORD PTR [esi+352], 2
	je	SHORT $L101018

; 382  : 	{
; 383  : 		if (PrePareFly())

	mov	ecx, esi
	call	?PrePareFly@KMissle@@AAEHXZ		; KMissle::PrePareFly
	test	eax, eax
	je	SHORT $L101015

; 384  : 		{
; 385  : #ifndef _SERVER
; 386  : 			int nSrcX2 = 0 ;
; 387  : 			int nSrcY2 = 0 ;
; 388  : 			SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX2, &nSrcY2);

	mov	eax, DWORD PTR [esi+232]
	lea	ecx, DWORD PTR _nSrcY2$101017[esp+12]
	lea	edx, DWORD PTR _nSrcX2$101016[esp+12]
	push	ecx
	mov	ecx, DWORD PTR [esi+228]
	push	edx
	mov	edx, DWORD PTR [esi+220]
	push	eax
	mov	eax, DWORD PTR [esi+216]
	push	ecx
	mov	ecx, DWORD PTR [esi+364]
	push	edx
	push	eax
	push	ecx
	mov	ecx, OFFSET FLAT:?SubWorld@@3PAVKSubWorld@@A
	mov	DWORD PTR _nSrcX2$101016[esp+40], 0
	mov	DWORD PTR _nSrcY2$101017[esp+40], 0
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 389  : 			m_MissleRes.PlaySound(MS_DoFly, nSrcX2, nSrcY2, 0);

	mov	edx, DWORD PTR _nSrcY2$101017[esp+12]
	mov	eax, DWORD PTR _nSrcX2$101016[esp+12]
	push	0
	push	edx
	push	eax
	push	1
	lea	ecx, DWORD PTR [esi+472]
	call	?PlaySoundA@KMissleRes@@QAEXHHHH@Z	; KMissleRes::PlaySoundA

; 390  : 			//CreateSpecialEffect(MS_DoFly, nSrcX2, nSrcY2, m_nCurrentMapZ);
; 391  : #endif
; 392  : 			
; 393  : 			DoFly();

	mov	ecx, esi
	call	?DoFly@KMissle@@AAEXXZ			; KMissle::DoFly

; 394  : 		}
; 395  : 		else

	jmp	SHORT $L101018
$L101015:

; 396  : 			DoVanish();

	mov	ecx, esi
	call	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
$L101018:

; 397  : 	}
; 398  : 	
; 399  : 	switch(m_eMissleStatus)
; 400  : 	{

	mov	eax, DWORD PTR [esi+352]
	cmp	eax, 3
	ja	$L101020
	jmp	DWORD PTR $L106026[eax*4]
$L101023:

; 401  : 	case MS_DoWait:
; 402  : 		{
; 403  : 			OnWait();

	mov	ecx, esi
	call	?OnWait@KMissle@@AAEXXZ			; KMissle::OnWait

; 404  : 		}
; 405  : 		break;

	jmp	$L101020
$L101024:

; 406  : 	case MS_DoFly:
; 407  : 		{
; 408  : 			OnFly();

	mov	ecx, esi
	call	?OnFly@KMissle@@AAEXXZ			; KMissle::OnFly

; 409  : 			if (m_bFlyEvent)

	mov	eax, DWORD PTR [esi+172]
	test	eax, eax
	je	SHORT $L101020

; 410  : 			{
; 411  : 				if ( (m_nCurrentLife - m_nStartLifeTime) % m_nFlyEventTime == 0 )

	mov	eax, DWORD PTR [esi+204]
	mov	ecx, DWORD PTR [esi+208]
	sub	eax, ecx
	cdq
	idiv	DWORD PTR [esi+176]
	test	edx, edx
	jne	SHORT $L101020

; 412  : 				{
; 413  : 					_ASSERT(m_nSkillId < MAX_SKILL && m_nLevel < MAX_SKILLLEVEL);
; 414  : 					if (m_nLevel  <= 0 ) return 0;

	mov	eax, DWORD PTR [esi+320]
	test	eax, eax
	jle	$L100998

; 415  : 					KSkill * pOrdinSkill = (KSkill *) g_SkillManager.GetSkill(m_nSkillId , m_nLevel);

	mov	ecx, DWORD PTR [esi+100]
	cmp	ecx, 2000				; 000007d0H
	jg	SHORT $L101020
	test	ecx, ecx
	jle	SHORT $L101020
	test	eax, eax
	jle	SHORT $L101020
	cmp	eax, 64					; 00000040H
	jg	SHORT $L101020
	mov	edx, ecx
	shl	edx, 6
	add	edx, eax
	mov	edx, DWORD PTR ?g_SkillManager@@3VKSkillManager@@A[edx*4+31740]
	test	edx, edx
	je	SHORT $L106021
	mov	eax, edx
	jmp	SHORT $L106016
$L106021:
	push	eax
	push	ecx
	mov	ecx, OFFSET FLAT:?g_SkillManager@@3VKSkillManager@@A
	call	?InstanceSkill@KSkillManager@@AAEPAVISkill@@KK@Z ; KSkillManager::InstanceSkill
$L106016:

; 416  : 					if (pOrdinSkill)

	test	eax, eax
	je	SHORT $L101020

; 417  : 					{
; 418  : 						pOrdinSkill->FlyEvent(this);

	push	esi
	mov	ecx, eax
	call	?FlyEvent@KSkill@@ABEXPAVKMissle@@@Z	; KSkill::FlyEvent

; 419  : 					}
; 420  : 				}
; 421  : 			}
; 422  : 		}
; 423  : 		break;

	jmp	SHORT $L101020
$L101032:

; 424  : 	case MS_DoCollision:
; 425  : 		{
; 426  : 			OnCollision();

	mov	ecx, esi
	call	?OnCollision@KMissle@@AAEXXZ		; KMissle::OnCollision

; 427  : 		}
; 428  : 		break;

	jmp	SHORT $L101020
$L101033:

; 429  : 	case MS_DoVanish:
; 430  : 		{
; 431  : 			OnVanish();

	mov	ecx, esi
	call	?OnVanish@KMissle@@AAEXXZ		; KMissle::OnVanish
$L101020:

; 432  : 		}
; 433  : 		break;
; 434  : 	}
; 435  : 	
; 436  : #ifndef _SERVER
; 437  : 	if (m_nMissleId > 0)

	mov	eax, DWORD PTR [esi+356]
	test	eax, eax
	jle	$L101038

; 438  : 	{
; 439  : 		int nSrcX;
; 440  : 		int nSrcY;
; 441  : 		
; 442  : 		SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX, &nSrcY);

	mov	edx, DWORD PTR [esi+232]
	lea	eax, DWORD PTR _nSrcY$101036[esp+12]
	lea	ecx, DWORD PTR _nSrcX$101035[esp+12]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET FLAT:?SubWorld@@3PAVKSubWorld@@A
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 443  : 		if (m_usLightRadius && m_eMissleStatus != MS_DoWait)

	cmp	WORD PTR [esi+468], 0
	je	SHORT $L101037
	mov	eax, DWORD PTR [esi+352]
	test	eax, eax
	je	SHORT $L101037

; 444  : 			g_ScenePlace.MoveObject(CGOG_MISSLE, m_nMissleId, nSrcX, nSrcY, m_nCurrentMapZ, m_SceneID, IPOT_RL_OBJECT | IPOT_RL_LIGHT_PROP );

	mov	edx, DWORD PTR [esi+224]
	mov	eax, DWORD PTR _nSrcY$101036[esp+12]
	lea	ecx, DWORD PTR [esi+2940]
	push	10					; 0000000aH
	push	ecx
	mov	ecx, DWORD PTR _nSrcX$101035[esp+20]
	push	edx
	mov	edx, DWORD PTR [esi+356]
	push	eax
	push	ecx
	push	edx

; 445  : 		else

	jmp	SHORT $L106025
$L101037:

; 446  : 			g_ScenePlace.MoveObject(CGOG_MISSLE, m_nMissleId, nSrcX, nSrcY, m_nCurrentMapZ, m_SceneID, IPOT_RL_OBJECT);

	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY$101036[esp+12]
	lea	eax, DWORD PTR [esi+2940]
	push	2
	push	eax
	mov	eax, DWORD PTR _nSrcX$101035[esp+20]
	push	ecx
	mov	ecx, DWORD PTR [esi+356]
	push	edx
	push	eax
	push	ecx
$L106025:
	push	9
	mov	ecx, OFFSET FLAT:?g_ScenePlace@@3VKScenePlaceC@@A
	call	?MoveObject@KScenePlaceC@@QAEIIHHHHAAIH@Z ; KScenePlaceC::MoveObject
$L101038:

; 447  : 	}
; 448  : 	
; 449  : #endif
; 450  : 	m_nCurrentLife ++;

	mov	eax, DWORD PTR [esi+204]
	inc	eax
	mov	DWORD PTR [esi+204], eax

; 451  : 	return 1;

	mov	eax, 1
	pop	esi

; 452  : }

	add	esp, 8
	ret	0
$L101002:

; 339  : 	{
; 340  : 		DoVanish();

	mov	ecx, esi
	call	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
$L100998:

; 328  : 	{
; 329  : 		return  0 ;

	xor	eax, eax
	pop	esi

; 452  : }

	add	esp, 8
	ret	0
	npad	3
$L106026:
	DD	$L101023
	DD	$L101024
	DD	$L101033
	DD	$L101032
?Activate@KMissle@@QAEHXZ ENDP				; KMissle::Activate
_TEXT	ENDS
;	COMDAT ?OnWait@KMissle@@AAEXXZ
_TEXT	SEGMENT
?OnWait@KMissle@@AAEXXZ PROC NEAR			; KMissle::OnWait, COMDAT

; 463  : 	return;
; 464  : }

	ret	0
?OnWait@KMissle@@AAEXXZ ENDP				; KMissle::OnWait
_TEXT	ENDS
;	COMDAT ?OnCollision@KMissle@@AAEXXZ
_TEXT	SEGMENT
?OnCollision@KMissle@@AAEXXZ PROC NEAR			; KMissle::OnCollision, COMDAT

; 474  : 	return;	
; 475  : }

	ret	0
?OnCollision@KMissle@@AAEXXZ ENDP			; KMissle::OnCollision
_TEXT	ENDS
PUBLIC	?DoCollision@KMissle@@AAEXXZ			; KMissle::DoCollision
PUBLIC	?FindNearestCollision@KMissle@@AAEHHH@Z		; KMissle::FindNearestCollision
PUBLIC	?CheckCollision@KMissle@@AAEHXZ			; KMissle::CheckCollision
PUBLIC	?ProcessCollision@KMissle@@AAEHHHHHHH@Z		; KMissle::ProcessCollision
PUBLIC	?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z	; KMissle::GetOffsetAxis
EXTRN	?FindNpc@KRegion@@QAEHHHHH@Z:NEAR		; KRegion::FindNpc
;	COMDAT ?CheckCollision@KMissle@@AAEHXZ
_TEXT	SEGMENT
_nRMx$ = -8
_nRMy$ = -12
_nSearchRegion$ = -4
?CheckCollision@KMissle@@AAEHXZ PROC NEAR		; KMissle::CheckCollision, COMDAT

; 479  : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx

; 480  : #ifdef TOOLVERSION
; 481  : 	return FALSE;
; 482  : #endif
; 483  : 	
; 484  : 	if (m_nCurrentMapZ <= MISSLE_MIN_COLLISION_ZHEIGHT) 

	xor	ebx, ebx
	push	edi
	mov	eax, DWORD PTR [esi+224]
	cmp	eax, ebx
	jg	SHORT $L101048
	pop	edi
	pop	esi

; 485  : 	{
; 486  : 		return -1;

	or	eax, -1
	pop	ebx

; 570  : }

	add	esp, 12					; 0000000cH
	ret	0
$L101048:

; 487  : 	}
; 488  : 	
; 489  : 	//
; 490  : 	if (m_nCurrentMapZ > MISSLE_MAX_COLLISION_ZHEIGHT) return 0;

	cmp	eax, 20					; 00000014H
	jg	$L101079

; 491  : 	
; 492  : 	if (m_nRegionId < 0) 

	cmp	DWORD PTR [esi+364], ebx
	jge	SHORT $L101050
	pop	edi
	pop	esi

; 493  : 	{
; 494  : 		return -1;

	or	eax, -1
	pop	ebx

; 570  : }

	add	esp, 12					; 0000000cH
	ret	0
$L101050:

; 495  : 	}
; 496  : 
; 497  : 	int nAbsX = 0;
; 498  : 	int nAbsY = 0;
; 499  : 	int nCellWidth = CellWidth;
; 500  : 	int nCellHeight = CellHeight;
; 501  : 	_ASSERT(nCellWidth > 0 && nCellHeight > 0);
; 502  : 	int nRMx = 0;
; 503  : 	int nRMy = 0;
; 504  : 	int nSearchRegion = 0;
; 505  : 	int nNpcIdx = 0;
; 506  : 	int nDX = 0;
; 507  : 	int nDY = 0;
; 508  : 	int nNpcOffsetX = 0;
; 509  : 	int nNpcOffsetY = 0;
; 510  : 	BOOL bCollision = FALSE;
; 511  : 	
; 512  : 	int nColRegion = m_nRegionId;
; 513  : 	int nColMapX = m_nCurrentMapX;
; 514  : 	int nColMapY = m_nCurrentMapY;
; 515  : 		
; 516  : 	if (m_nCollideRange == 1)

	mov	eax, DWORD PTR [esi+144]
	mov	DWORD PTR _nRMx$[esp+24], ebx
	cmp	eax, 1
	mov	DWORD PTR _nRMy$[esp+24], ebx
	mov	DWORD PTR _nSearchRegion$[esp+24], ebx
	jne	$L101068

; 517  : 	{
; 518  : 		/*if (m_bNeedReclaim && m_nCurrentLife >= m_nFirstReclaimTime && m_nCurrentLife <= m_nEndReclaimTime)
; 519  : 		{
; 520  : 			if (m_nCurrentLife == m_nEndReclaimTime) 
; 521  : 				m_bNeedReclaim = FALSE;
; 522  : 			nNpcIdx = 	CheckNearestCollision();
; 523  : 		}
; 524  : 		else
; 525  : 		{
; 526  : 			nNpcIdx = SubWorld[m_nSubWorldId].m_Region[nColRegion].FindNpc(nColMapX, nColMapY, m_nLauncher, m_eRelation);
; 527  : 		}*/
; 528  : 		//fix miss
; 529  : 		nNpcIdx = FindNearestCollision(m_nLauncher, m_eRelation);

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+332]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?FindNearestCollision@KMissle@@AAEHHH@Z	; KMissle::FindNearestCollision
	mov	edi, eax

; 530  : 
; 531  : 		if (nNpcIdx > 0)

	cmp	edi, ebx
	jle	$L101079

; 532  : 		{
; 533  : 			if (m_nDamageRange == 1)

	cmp	DWORD PTR [esi+148], 1
	jne	SHORT $L101070

; 534  : 				ProcessCollision(m_nLauncher, Npc[nNpcIdx].m_RegionIndex, Npc[nNpcIdx].m_MapX, Npc[nNpcIdx].m_MapY, m_nDamageRange, m_eRelation);

	lea	eax, DWORD PTR [edi+edi*2]
	mov	edx, DWORD PTR [esi+108]
	shl	eax, 3
	sub	eax, edi
	push	edx
	push	1
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, edi
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3116]
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3112]
	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2608]
	push	ecx
	mov	ecx, DWORD PTR [esi+332]
	push	edx
	push	eax
	push	ecx
	mov	ecx, esi
	call	?ProcessCollision@KMissle@@AAEHHHHHHH@Z	; KMissle::ProcessCollision

; 535  : 			else

	jmp	SHORT $L101071
$L101070:

; 536  : 				ProcessCollision();

	mov	ecx, esi
	call	?ProcessCollision@KMissle@@AAEHXZ	; KMissle::ProcessCollision
$L101071:

; 537  : 			if (m_nLastDoCollisionIdx == nNpcIdx)

	cmp	DWORD PTR [esi+444], edi
	je	SHORT $L101073

; 538  : 			{
; 539  : 				//return 1; thu bo cho nay xem sao
; 540  : 			}
; 541  : 			else
; 542  : 			{
; 543  : 				if (this->m_eMoveKind == MISSLE_MMK_Line)

	cmp	DWORD PTR [esi+76], 1
	jne	SHORT $L101074

; 544  : 					m_nLastDoCollisionIdx = nNpcIdx;

	mov	DWORD PTR [esi+444], edi
$L101074:

; 545  : 				DoCollision();

	mov	ecx, esi
	call	?DoCollision@KMissle@@AAEXXZ		; KMissle::DoCollision
$L101073:
	pop	edi
	pop	esi

; 546  : 			}
; 547  : 			return 1;

	mov	eax, 1
	pop	ebx

; 570  : }

	add	esp, 12					; 0000000cH
	ret	0
$L101068:

; 548  : 		}
; 549  : 	}
; 550  : 	else
; 551  : 	{
; 552  : 		for (int i = -m_nCollideRange; i <= m_nCollideRange; i ++)

	mov	ebx, eax
	neg	ebx
	cmp	ebx, eax
	jg	$L101079
$L101077:

; 553  : 			for (int j = -m_nCollideRange; j <= m_nCollideRange; j ++)

	mov	edi, eax
	neg	edi
	cmp	edi, eax
	jg	$L101078
$L101081:

; 554  : 			{
; 555  : 				if (!GetOffsetAxis(m_nSubWorldId, m_nRegionId, m_nCurrentMapX, m_nCurrentMapY, i , j , nSearchRegion, nRMx, nRMy))

	lea	edx, DWORD PTR _nRMy$[esp+24]
	lea	eax, DWORD PTR _nRMx$[esp+24]
	push	edx
	mov	edx, DWORD PTR [esi+220]
	lea	ecx, DWORD PTR _nSearchRegion$[esp+28]
	push	eax
	mov	eax, DWORD PTR [esi+216]
	push	ecx
	mov	ecx, DWORD PTR [esi+364]
	push	edi
	push	ebx
	push	edx
	mov	edx, DWORD PTR [esi+360]
	push	eax
	push	ecx
	push	edx
	call	?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z ; KMissle::GetOffsetAxis
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $L101082

; 556  : 					continue;
; 557  : 				
; 558  : 				_ASSERT(nSearchRegion >= 0);
; 559  : 				nNpcIdx = SubWorld[m_nSubWorldId].m_Region[nSearchRegion].FindNpc(nRMx, nRMy, m_nLauncher, m_eRelation);

	mov	eax, DWORD PTR [esi+108]
	mov	ecx, DWORD PTR [esi+332]
	mov	edx, DWORD PTR _nRMy$[esp+24]
	push	eax
	mov	eax, DWORD PTR _nRMx$[esp+28]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, eax
	shl	ecx, 6
	sub	ecx, eax
	mov	eax, DWORD PTR _nSearchRegion$[esp+40]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4+40]
	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+edx*4]
	shl	eax, 4
	add	ecx, eax
	call	?FindNpc@KRegion@@QAEHHHHH@Z		; KRegion::FindNpc

; 560  : 				if (nNpcIdx > 0)

	test	eax, eax
	jg	SHORT $L106038
$L101082:

; 553  : 			for (int j = -m_nCollideRange; j <= m_nCollideRange; j ++)

	mov	eax, DWORD PTR [esi+144]
	inc	edi
	cmp	edi, eax
	jle	$L101081
$L101078:

; 548  : 		}
; 549  : 	}
; 550  : 	else
; 551  : 	{
; 552  : 		for (int i = -m_nCollideRange; i <= m_nCollideRange; i ++)

	mov	eax, DWORD PTR [esi+144]
	inc	ebx
	cmp	ebx, eax
	jle	$L101077
$L101079:
	pop	edi
	pop	esi

; 565  : 				}
; 566  : 			}
; 567  : 	}
; 568  : 	
; 569  : 	return 0;

	xor	eax, eax
	pop	ebx

; 570  : }

	add	esp, 12					; 0000000cH
	ret	0
$L106038:

; 561  : 				{
; 562  : 					ProcessCollision();

	mov	ecx, esi
	call	?ProcessCollision@KMissle@@AAEHXZ	; KMissle::ProcessCollision

; 563  : 					DoCollision();

	mov	ecx, esi
	call	?DoCollision@KMissle@@AAEXXZ		; KMissle::DoCollision
	pop	edi
	pop	esi

; 564  : 					return 1;

	mov	eax, 1
	pop	ebx

; 570  : }

	add	esp, 12					; 0000000cH
	ret	0
?CheckCollision@KMissle@@AAEHXZ ENDP			; KMissle::CheckCollision
_TEXT	ENDS
PUBLIC	?Send@KWorldMsg@@QAEHKHHH@Z			; KWorldMsg::Send
PUBLIC	?CheckBeyondRegion@KMissle@@AAEHHH@Z		; KMissle::CheckBeyondRegion
PUBLIC	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
EXTRN	?AddRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z:NEAR	; KRegion::AddRef
EXTRN	?DecRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z:NEAR	; KRegion::DecRef
EXTRN	?GetDistance@KSubWorld@@QAEHHHHH@Z:NEAR		; KSubWorld::GetDistance
EXTRN	?Mps2Map@KSubWorld@@QAEXHHPAH0000@Z:NEAR	; KSubWorld::Mps2Map
EXTRN	?TestBarrier@KSubWorld@@QAEEHHHHHHH@Z:NEAR	; KSubWorld::TestBarrier
EXTRN	?GetMpsPos@KNpc@@QAEXPAH0@Z:NEAR		; KNpc::GetMpsPos
EXTRN	__fltused:NEAR
EXTRN	?g_nSin@@3PAHA:DWORD				; g_nSin
EXTRN	?g_nCos@@3PAHA:DWORD				; g_nCos
EXTRN	?g_InternalDirSinCosCode@@3PAEA:DWORD		; g_InternalDirSinCosCode
;	COMDAT ?OnFly@KMissle@@AAEXXZ
_TEXT	SEGMENT
_fi$106143 = -8
_tmp$106147 = -8
_nRet$106149 = -16
_nPX$101095 = -12
_nPY$101096 = -24
_nSrcX2$101099 = -20
_nSrcY2$101100 = -16
_nSrcX3$101102 = -20
_nSrcY3$101103 = -16
_nPreAngle$101118 = -20
_dx$101121 = -24
_dy$101122 = -12
_nPX$101125 = -16
_nPY$101126 = -28
_nSrcMpsX$101131 = -20
_nSrcMpsY$101132 = -32
_nOldRegion$101133 = -8
_nPreAngle$101140 = -20
_dx$101143 = -12
_dy$101144 = -8
_nSrcMpsX$101155 = -28
_nSrcMpsY$101156 = -20
_nDesMpsX$101157 = -32
_nDesMpsY$101158 = -24
_nSrcX4$101175 = -16
_nSrcY4$101176 = -12
?OnFly@KMissle@@AAEXXZ PROC NEAR			; KMissle::OnFly, COMDAT

; 578  : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx

; 579  : 	if (m_nInteruptTypeWhenMove)

	xor	ebx, ebx
	push	edi
	mov	eax, DWORD PTR [esi+128]
	cmp	eax, ebx
	je	$L101097

; 580  : 	{
; 581  : 		if (m_nInteruptTypeWhenMove == Interupt_EndOldMissleLifeWhenMove)

	cmp	eax, 2
	jne	$L101097

; 582  : 		{
; 583  : 			int nPX, nPY;
; 584  : 			Npc[m_nLauncher].GetMpsPos(&nPX, &nPY);

	lea	eax, DWORD PTR _nPY$101096[esp+48]
	lea	ecx, DWORD PTR _nPX$101095[esp+48]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+332]
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	lea	edx, DWORD PTR [eax+eax*8]
	lea	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[edx*4]
	call	?GetMpsPos@KNpc@@QAEXPAH0@Z		; KNpc::GetMpsPos

; 585  : 			if (nPX != m_nLauncherSrcPX || nPY != m_nLauncherSrcPY)

	mov	eax, DWORD PTR _nPX$101095[esp+48]
	mov	ecx, DWORD PTR [esi+136]
	cmp	eax, ecx
	jne	SHORT $L101098
	mov	ecx, DWORD PTR _nPY$101096[esp+48]
	mov	eax, DWORD PTR [esi+140]
	cmp	ecx, eax
	je	SHORT $L101097
$L101098:

; 586  : 			{
; 587  : 				
; 588  : #ifndef _SERVER 
; 589  : 				int nSrcX2 = 0 ;
; 590  : 				int nSrcY2 = 0 ;
; 591  : 				SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX2, &nSrcY2);

	mov	ecx, DWORD PTR [esi+232]
	lea	edx, DWORD PTR _nSrcY2$101100[esp+48]
	lea	eax, DWORD PTR _nSrcX2$101099[esp+48]
	push	edx
	mov	edx, DWORD PTR [esi+228]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	push	ecx
	mov	ecx, DWORD PTR [esi+216]
	push	edx
	mov	edx, DWORD PTR [esi+364]
	push	eax
	push	ecx
	push	edx
	mov	ecx, OFFSET FLAT:?SubWorld@@3PAVKSubWorld@@A
	mov	DWORD PTR _nSrcX2$101099[esp+76], ebx
	mov	DWORD PTR _nSrcY2$101100[esp+76], ebx
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 592  : 				CreateSpecialEffect(MS_DoVanish, nSrcX2, nSrcY2, m_nCurrentMapZ);

	mov	eax, DWORD PTR [esi+224]
	mov	ecx, DWORD PTR _nSrcY2$101100[esp+48]
	mov	edx, DWORD PTR _nSrcX2$101099[esp+48]
	push	ebx
	push	eax
	push	ecx
	push	edx

; 593  : #endif
; 594  : 				
; 595  : 				DoVanish();
; 596  : 				return ;

	jmp	$L106179
$L101097:

; 597  : 			}
; 598  : 		}
; 599  : 	}
; 600  : 	
; 601  : 	if (TestBarrier()) 

	mov	eax, DWORD PTR [esi+232]
	mov	ecx, DWORD PTR [esi+228]
	mov	edx, DWORD PTR [esi+220]
	lea	ebp, DWORD PTR [esi+220]
	push	ebx
	push	ebx
	push	eax
	mov	eax, DWORD PTR [esi+216]
	push	ecx
	push	edx
	mov	ecx, DWORD PTR [esi+364]
	push	eax
	mov	eax, DWORD PTR [esi+360]
	lea	edi, DWORD PTR [esi+364]
	mov	edx, eax
	push	ecx
	shl	edx, 6
	sub	edx, eax
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4]
	call	?TestBarrier@KSubWorld@@QAEEHHHHHHH@Z	; KSubWorld::TestBarrier
	and	eax, 255				; 000000ffH
	cmp	eax, 1
	je	SHORT $L106049
	cmp	eax, 3
	jne	SHORT $L101101
$L106049:

; 602  : 	{
; 603  : #ifndef _SERVER 
; 604  : 		int nSrcX3 = 0 ;
; 605  : 		int nSrcY3 = 0 ;
; 606  : 		SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX3, &nSrcY3);

	mov	edx, DWORD PTR [esi+232]
	lea	eax, DWORD PTR _nSrcY3$101103[esp+48]
	lea	ecx, DWORD PTR _nSrcX3$101102[esp+48]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [edi]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET FLAT:?SubWorld@@3PAVKSubWorld@@A
	mov	DWORD PTR _nSrcX3$101102[esp+76], ebx
	mov	DWORD PTR _nSrcY3$101103[esp+76], ebx
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 607  : 		CreateSpecialEffect(MS_DoVanish, nSrcX3, nSrcY3, m_nCurrentMapZ);

	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY3$101103[esp+48]
	mov	eax, DWORD PTR _nSrcX3$101102[esp+48]
	push	ebx
	push	ecx
	push	edx

; 608  : #endif
; 609  : 		DoVanish();
; 610  : 		return;

	jmp	$L106180
$L101101:

; 611  : 	}
; 612  : 	
; 613  : 	int nDOffsetX = 0;
; 614  : 	int nDOffsetY = 0;
; 615  : 	
; 616  : 	ZAxisMove();			

	mov	ebx, DWORD PTR [esi+348]
	xor	eax, eax
	xor	ecx, ecx
	test	ebx, ebx
	je	SHORT $L106053
	mov	edx, DWORD PTR [esi+88]
	add	DWORD PTR [esi+84], edx
	jns	SHORT $L106054
	mov	DWORD PTR [esi+84], ecx
$L106054:
	sub	edx, ebx
	mov	DWORD PTR [esi+88], edx
	mov	edx, DWORD PTR [esi+84]
	sar	edx, 10					; 0000000aH
	mov	DWORD PTR [esi+224], edx
$L106053:

; 617  : 	switch(this->m_eMoveKind)
; 618  : 	{

	mov	edx, DWORD PTR [esi+76]
	dec	edx
	cmp	edx, 99					; 00000063H
	ja	$L101170
	xor	ebx, ebx
	mov	bl, BYTE PTR $L106181[edx]
	jmp	DWORD PTR $L106182[ebx*4]
$L101112:

; 619  : 	case	MISSLE_MMK_Stand:							
; 620  : 		{
; 621  : 			
; 622  : 		}
; 623  : 		break;
; 624  : 	case	MISSLE_MMK_Parabola:
; 625  : 	case	MISSLE_MMK_Line:							
; 626  : 		{
; 627  : 			nDOffsetX = (m_nSpeed * m_nXFactor);
; 628  : 			nDOffsetY = (m_nSpeed * m_nYFactor);
; 629  : 		}
; 630  : 		break;
; 631  : 	case MISSLE_MMK_RollBack:
; 632  : 		{
; 633  : 			if (!m_nTempParam1)	

	mov	eax, DWORD PTR [esi+412]
	test	eax, eax
	jne	$L101111

; 634  : 			{
; 635  : 				if (m_nTempParam2 <= m_nCurrentLife)

	mov	eax, DWORD PTR [esi+416]
	mov	ecx, DWORD PTR [esi+204]
	cmp	eax, ecx
	jg	$L101111

; 636  : 				{
; 637  : 					m_nXFactor = -m_nXFactor;

	mov	ecx, DWORD PTR [esi+312]

; 638  : 					m_nYFactor = -m_nYFactor;

	mov	edx, DWORD PTR [esi+316]

; 639  : 					m_nTempParam1 = 1;
; 640  : 					m_nDir = m_nDir - MaxMissleDir / 2;

	mov	eax, DWORD PTR [esi+424]
	mov	DWORD PTR [esi+412], 1
	neg	ecx
	neg	edx
	add	eax, -32				; ffffffe0H
	mov	DWORD PTR [esi+312], ecx
	mov	DWORD PTR [esi+316], edx
	mov	DWORD PTR [esi+424], eax

; 641  : 					if (m_nDir < 0) m_nDir += MaxMissleDir;

	jns	$L101111
	add	eax, 64					; 00000040H
	mov	DWORD PTR [esi+424], eax

; 642  : 				}
; 643  : 			}
; 644  : 
; 645  : 			nDOffsetX = (m_nSpeed * m_nXFactor);
; 646  : 			nDOffsetY = (m_nSpeed * m_nYFactor);
; 647  : 		}
; 648  : 		break;

	jmp	$L101111
$L101117:

; 649  : 	case	MISSLE_MMK_Random:						
; 650  : 		{
; 651  : 			
; 652  : 		}
; 653  : 		break;
; 654  : 	case	MISSLE_MMK_Circle:
; 655  : 		{
; 656  : 			int nPreAngle = m_nAngle - 1;

	mov	eax, DWORD PTR [esi+428]
	lea	ecx, DWORD PTR [eax-1]

; 657  : 			if (nPreAngle < 0) nPreAngle = MaxMissleDir - 1;

	test	ecx, ecx
	mov	DWORD PTR _nPreAngle$101118[esp+48], ecx
	jge	SHORT $L101119
	mov	DWORD PTR _nPreAngle$101118[esp+48], 63	; 0000003fH
$L101119:

; 658  : 			m_nDir = m_nAngle + (MaxMissleDir / 4);

	lea	ecx, DWORD PTR [eax+16]

; 659  : 			if (m_nDir >= MaxMissleDir) m_nDir = m_nDir - MaxMissleDir;

	cmp	ecx, 64					; 00000040H
	mov	DWORD PTR [esi+424], ecx
	jl	SHORT $L101120
	add	ecx, -64				; ffffffc0H
	mov	DWORD PTR [esi+424], ecx
$L101120:

; 660  : 			int dx = (m_nSpeed + m_nParam3)  * (g_DirCos(m_nAngle,MaxMissleDir) - g_DirCos(nPreAngle,MaxMissleDir)) ;

	push	64					; 00000040H
	push	eax
	mov	eax, DWORD PTR ?g_nCos@@3PAHA		; g_nCos
	push	eax
	call	DWORD PTR ?g_InternalDirSinCosCode@@3PAEA ; g_InternalDirSinCosCode
	mov	ecx, DWORD PTR _nPreAngle$101118[esp+60]
	mov	edx, DWORD PTR ?g_nCos@@3PAHA		; g_nCos
	push	64					; 00000040H
	push	ecx
	push	edx
	mov	ebx, eax
	call	DWORD PTR ?g_InternalDirSinCosCode@@3PAEA ; g_InternalDirSinCosCode
	mov	ecx, DWORD PTR [esi+96]
	sub	ebx, eax
	mov	eax, DWORD PTR [esi+400]

; 661  : 			int dy = (m_nSpeed + m_nParam3)  * (g_DirSin(m_nAngle,MaxMissleDir) - g_DirSin(nPreAngle, MaxMissleDir)) ; 

	push	64					; 00000040H
	add	eax, ecx
	mov	ecx, DWORD PTR ?g_nSin@@3PAHA		; g_nSin
	imul	ebx, eax
	mov	eax, DWORD PTR [esi+428]
	mov	DWORD PTR _dx$101121[esp+76], ebx
	push	eax
	push	ecx
	call	DWORD PTR ?g_InternalDirSinCosCode@@3PAEA ; g_InternalDirSinCosCode
	mov	edx, DWORD PTR _nPreAngle$101118[esp+84]
	mov	ebx, eax
	mov	eax, DWORD PTR ?g_nSin@@3PAHA		; g_nSin
	push	64					; 00000040H
	push	edx
	push	eax
	call	DWORD PTR ?g_InternalDirSinCosCode@@3PAEA ; g_InternalDirSinCosCode
	mov	ecx, DWORD PTR [esi+400]
	mov	edx, DWORD PTR [esi+96]
	sub	ebx, eax
	add	ecx, edx
	imul	ebx, ecx

; 662  : 			
; 663  : 			if (m_nParam2)

	mov	eax, DWORD PTR [esi+396]
	add	esp, 48					; 00000030H
	mov	ecx, ebx
	test	eax, eax
	mov	DWORD PTR _dy$101122[esp+48], ecx
	je	SHORT $L101123

; 664  : 			{	
; 665  : 				nDOffsetX = dx;

	mov	eax, DWORD PTR _dx$101121[esp+48]

; 666  : 				nDOffsetY = dy;
; 667  : 			}
; 668  : 			else

	jmp	$L101124
$L101123:

; 669  : 			{		
; 670  : 				int nPX, nPY;
; 671  : 				Npc[m_nLauncher].GetMpsPos(&nPX, &nPY);

	mov	ecx, DWORD PTR [esi+332]
	lea	edx, DWORD PTR _nPY$101126[esp+48]
	lea	eax, DWORD PTR _nPX$101125[esp+48]
	push	edx
	push	eax
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	lea	ecx, DWORD PTR [eax+eax*8]
	lea	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[ecx*4]
	call	?GetMpsPos@KNpc@@QAEXPAH0@Z		; KNpc::GetMpsPos

; 672  : 				if (nPX != m_nLauncherSrcPX || nPY != m_nLauncherSrcPY)

	mov	edx, DWORD PTR _nPX$101125[esp+48]
	mov	eax, DWORD PTR [esi+136]
	cmp	edx, eax
	jne	SHORT $L101128
	mov	eax, DWORD PTR _nPY$101126[esp+48]
	mov	ecx, DWORD PTR [esi+140]
	cmp	eax, ecx
	je	$L101134
$L101128:

; 673  : 				{		
; 674  : 					int a = nPX - m_nLauncherSrcPX;
; 675  : 					int b = nPY - m_nLauncherSrcPY;
; 676  : 					int nSrcMpsX, nSrcMpsY;
; 677  : 					int nOldRegion = m_nRegionId;

	mov	eax, DWORD PTR [edi]

; 678  : 					SubWorld[m_nSubWorldId].Map2Mps(nOldRegion, m_nCurrentMapX, m_nCurrentMapY, m_nXOffset, m_nYOffset, &nSrcMpsX, &nSrcMpsY);	

	lea	ecx, DWORD PTR _nSrcMpsY$101132[esp+48]
	lea	edx, DWORD PTR _nSrcMpsX$101131[esp+48]
	push	ecx
	mov	ecx, DWORD PTR [esi+232]
	push	edx
	mov	edx, DWORD PTR [esi+228]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	ecx
	push	edx
	mov	DWORD PTR _nOldRegion$101133[esp+72], eax
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, eax
	shl	ecx, 6
	sub	ecx, eax
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4]
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 679  : 					CurRegion.DecRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [esi+216]
	push	2
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, eax
	shl	ecx, 6
	sub	ecx, eax
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4+40]
	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+edx*4]
	shl	eax, 4
	add	ecx, eax
	call	?DecRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::DecRef

; 680  : 					nSrcMpsX = nPX + (nSrcMpsX - m_nLauncherSrcPX + dx) / (m_nParam3 * 2);

	mov	eax, DWORD PTR _nSrcMpsX$101131[esp+48]
	mov	ebx, DWORD PTR [esi+136]
	mov	edx, DWORD PTR _dx$101121[esp+48]
	mov	ecx, DWORD PTR [esi+400]
	sub	eax, ebx
	add	eax, edx
	cdq
	shl	ecx, 1
	idiv	ecx

; 681  : 					nSrcMpsY = nPY + (nSrcMpsY - m_nLauncherSrcPY + dy)/ (m_nParam3 * 2);

	mov	edx, DWORD PTR [esi+140]
	mov	ebx, eax
	mov	eax, DWORD PTR _nPX$101125[esp+48]
	add	ebx, eax
	mov	eax, DWORD PTR _nSrcMpsY$101132[esp+48]
	sub	eax, edx
	mov	edx, DWORD PTR _dy$101122[esp+48]
	add	eax, edx
	mov	DWORD PTR _nSrcMpsX$101131[esp+48], ebx
	cdq
	idiv	ecx
	mov	ecx, DWORD PTR _nPY$101126[esp+48]
	add	eax, ecx

; 682  : 					SubWorld[m_nSubWorldId].Mps2Map(nSrcMpsX, nSrcMpsY, &m_nRegionId, &m_nCurrentMapX, &m_nCurrentMapY, &m_nXOffset, &m_nYOffset);

	lea	ecx, DWORD PTR [esi+232]
	push	ecx
	lea	ecx, DWORD PTR [esi+228]
	push	ecx
	lea	ecx, DWORD PTR [esi+216]
	push	ebp
	push	ecx
	push	edi
	mov	DWORD PTR _nSrcMpsY$101132[esp+68], eax
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, eax
	push	ebx
	shl	ecx, 6
	sub	ecx, eax
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4]
	call	?Mps2Map@KSubWorld@@QAEXHHPAH0000@Z	; KSubWorld::Mps2Map

; 683  : 					CurRegion.AddRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	edx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [esi+216]
	push	2
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, eax
	shl	ecx, 6
	sub	ecx, eax
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4+40]
	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+edx*4]
	shl	eax, 4
	add	ecx, eax
	call	?AddRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::AddRef

; 684  : 					
; 685  : 					if (nOldRegion != m_nRegionId)

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _nOldRegion$101133[esp+48]
	cmp	ecx, eax
	je	SHORT $L101134

; 686  : 					{
; 687  : 						SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_CHANGE_REGION, nOldRegion, m_nRegionId, m_nMissleId);	

	mov	edx, DWORD PTR [esi+356]
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+360]
	push	ecx
	mov	ecx, eax
	push	4002					; 00000fa2H
	shl	ecx, 6
	sub	ecx, eax
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4+204]
	call	?Send@KWorldMsg@@QAEHKHHH@Z		; KWorldMsg::Send
$L101134:

; 688  : 					} 
; 689  : 				}
; 690  : 		
; 691  : 				nDOffsetX = dx;

	mov	eax, DWORD PTR _dx$101121[esp+48]

; 692  : 				nDOffsetY = dy;

	mov	ecx, DWORD PTR _dy$101122[esp+48]
$L101124:

; 693  : 			}
; 694  : 			if (m_nParam1)

	mov	edx, DWORD PTR [esi+392]
	test	edx, edx
	je	$L101135

; 695  : 			{
; 696  : 				m_nAngle ++;
; 697  : 				if (m_nAngle >= MaxMissleDir)
; 698  : 					m_nAngle = 0;
; 699  : 			}
; 700  : 			else

	jmp	$L106178
$L101139:

; 701  : 			{
; 702  : 				m_nAngle--;
; 703  : 				if (m_nAngle < 0 )
; 704  : 					m_nAngle = MaxMissleDir - 1;
; 705  : 			}
; 706  : 			
; 707  : 		}
; 708  : 		break;
; 709  : 	case	MISSLE_MMK_Helix:
; 710  : 		{
; 711  : 			int nPreAngle = m_nAngle - 1;

	mov	eax, DWORD PTR [esi+428]
	lea	ecx, DWORD PTR [eax-1]

; 712  : 			if (nPreAngle < 0) 

	test	ecx, ecx
	mov	DWORD PTR _nPreAngle$101140[esp+48], ecx
	jge	SHORT $L101141

; 713  : 			{
; 714  : 				nPreAngle = MaxMissleDir -1;

	mov	DWORD PTR _nPreAngle$101140[esp+48], 63	; 0000003fH
$L101141:

; 715  : 			}
; 716  : 			m_nDir = m_nAngle + (MaxMissleDir / 4);

	lea	ecx, DWORD PTR [eax+16]

; 717  : 			if (m_nDir >= MaxMissleDir) m_nDir = m_nDir - MaxMissleDir;

	cmp	ecx, 64					; 00000040H
	mov	DWORD PTR [esi+424], ecx
	jl	SHORT $L101142
	add	ecx, -64				; ffffffc0H
	mov	DWORD PTR [esi+424], ecx
$L101142:

; 718  : 			
; 719  : 			int dx = (m_nSpeed + m_nCurrentLife + 50)  * (g_DirCos(m_nAngle,MaxMissleDir) - g_DirCos(nPreAngle, MaxMissleDir)) ;

	mov	edx, DWORD PTR ?g_nCos@@3PAHA		; g_nCos
	push	64					; 00000040H
	push	eax
	push	edx
	call	DWORD PTR ?g_InternalDirSinCosCode@@3PAEA ; g_InternalDirSinCosCode
	mov	ecx, DWORD PTR ?g_nCos@@3PAHA		; g_nCos
	mov	ebx, eax
	mov	eax, DWORD PTR _nPreAngle$101140[esp+60]
	push	64					; 00000040H
	push	eax
	push	ecx
	call	DWORD PTR ?g_InternalDirSinCosCode@@3PAEA ; g_InternalDirSinCosCode
	mov	edx, DWORD PTR [esi+96]
	sub	ebx, eax
	mov	eax, DWORD PTR [esi+204]

; 720  : 			int dy = (m_nSpeed + m_nCurrentLife + 50)  * (g_DirSin(m_nAngle,MaxMissleDir) - g_DirSin(nPreAngle,MaxMissleDir)) ; 

	push	64					; 00000040H
	lea	ecx, DWORD PTR [edx+eax+50]
	mov	eax, DWORD PTR [esi+428]
	imul	ebx, ecx
	mov	edx, DWORD PTR ?g_nSin@@3PAHA		; g_nSin
	push	eax
	push	edx
	mov	DWORD PTR _dx$101143[esp+84], ebx
	call	DWORD PTR ?g_InternalDirSinCosCode@@3PAEA ; g_InternalDirSinCosCode
	mov	ecx, DWORD PTR ?g_nSin@@3PAHA		; g_nSin
	mov	ebx, eax
	mov	eax, DWORD PTR _nPreAngle$101140[esp+84]
	push	64					; 00000040H
	push	eax
	push	ecx
	call	DWORD PTR ?g_InternalDirSinCosCode@@3PAEA ; g_InternalDirSinCosCode
	mov	edx, DWORD PTR [esi+96]
	sub	ebx, eax
	mov	eax, DWORD PTR [esi+204]
	add	esp, 48					; 00000030H
	lea	ecx, DWORD PTR [edx+eax+50]

; 721  : 			
; 722  : 			if (m_nParam2) //

	mov	eax, DWORD PTR [esi+396]
	imul	ebx, ecx
	mov	ecx, ebx
	test	eax, eax
	mov	DWORD PTR _dy$101144[esp+48], ecx
	je	SHORT $L101145

; 723  : 			{
; 724  : 				nDOffsetX = dx;

	mov	eax, DWORD PTR _dx$101143[esp+48]

; 725  : 				nDOffsetY = dy;
; 726  : 			}
; 727  : 			else			// 

	jmp	$L101146
$L101145:

; 728  : 			{
; 729  : 				int nOldRegion = m_nRegionId;
; 730  : 				CurRegion.DecRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	edx, DWORD PTR [ebp]
	mov	ecx, DWORD PTR [esi+216]
	mov	eax, DWORD PTR [edi]
	push	2
	push	edx
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	mov	ebx, eax
	mov	edx, ecx
	shl	edx, 6
	sub	edx, ecx
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+40]
	shl	eax, 4
	add	ecx, eax
	call	?DecRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::DecRef

; 731  : 				m_nRegionId		= Npc[m_nLauncher].m_RegionIndex;

	mov	ecx, DWORD PTR [esi+332]

; 732  : 				m_nCurrentMapX	= Npc[m_nLauncher].m_MapX;
; 733  : 				m_nCurrentMapY	= Npc[m_nLauncher].m_MapY;
; 734  : 				m_nXOffset		= Npc[m_nLauncher].m_OffX;
; 735  : 				m_nYOffset		= Npc[m_nLauncher].m_OffY;
; 736  : 				CurRegion.AddRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	push	2
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2608]
	mov	DWORD PTR [edi], ecx
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3112]
	mov	DWORD PTR [esi+216], edx
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3116]
	mov	DWORD PTR [ebp], ecx
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3124]
	mov	DWORD PTR [esi+228], edx
	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3128]
	mov	DWORD PTR [esi+232], eax
	mov	eax, DWORD PTR [esi+360]
	mov	edx, DWORD PTR [esi+216]
	push	ecx
	mov	ecx, eax
	push	edx
	shl	ecx, 6
	sub	ecx, eax
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4+40]
	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+edx*4]
	shl	eax, 4
	add	ecx, eax
	call	?AddRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::AddRef

; 737  : 				
; 738  : 				if (nOldRegion != m_nRegionId)

	mov	eax, DWORD PTR [edi]
	cmp	ebx, eax
	je	SHORT $L101148

; 739  : 				{
; 740  : 					SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_CHANGE_REGION, nOldRegion, m_nRegionId, m_nMissleId);

	mov	ecx, DWORD PTR [esi+356]
	push	ecx
	push	eax
	mov	eax, DWORD PTR [esi+360]
	push	ebx
	mov	edx, eax
	push	4002					; 00000fa2H
	shl	edx, 6
	sub	edx, eax
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+204]
	call	?Send@KWorldMsg@@QAEHKHHH@Z		; KWorldMsg::Send
$L101148:

; 741  : 				}  
; 742  : 				nDOffsetX = dx;

	mov	eax, DWORD PTR _dx$101143[esp+48]

; 743  : 				nDOffsetY = dy;

	mov	ecx, DWORD PTR _dy$101144[esp+48]
$L101146:

; 744  : 			}
; 745  : 			
; 746  : 			if (m_nParam1)

	mov	edx, DWORD PTR [esi+392]
	test	edx, edx
	je	SHORT $L101135
$L106178:

; 747  : 			{
; 748  : 				m_nAngle ++;

	mov	ebx, DWORD PTR [esi+428]
	inc	ebx

; 749  : 				if (m_nAngle >= MaxMissleDir)

	mov	edx, ebx
	mov	DWORD PTR [esi+428], ebx
	cmp	edx, 64					; 00000040H
	jl	$L101170

; 750  : 					m_nAngle = 0;

	mov	DWORD PTR [esi+428], 0

; 751  : 			}
; 752  : 			else

	jmp	$L101170
$L101135:

; 753  : 			{
; 754  : 				m_nAngle--;

	mov	edx, DWORD PTR [esi+428]
	dec	edx
	mov	DWORD PTR [esi+428], edx

; 755  : 				if (m_nAngle < 0 )

	jns	$L101170

; 756  : 					m_nAngle = MaxMissleDir - 1;

	mov	DWORD PTR [esi+428], 63			; 0000003fH

; 757  : 			}
; 758  : 		}
; 759  : 		break; 

	jmp	$L101170
$L101153:

; 760  : 	case	MISSLE_MMK_Follow:
; 761  : 		{
; 762  : 			int nDistance = 0;
; 763  : 			int nSrcMpsX = 0;
; 764  : 			int nSrcMpsY = 0;
; 765  : 			int nDesMpsX = 0;
; 766  : 			int nDesMpsY = 0;
; 767  : 			
; 768  : 			if (m_nParam1++ >= MAX_RANGE_FOLLOW)

	mov	eax, DWORD PTR [esi+392]
	xor	edx, edx
	cmp	eax, 6
	mov	DWORD PTR _nSrcMpsX$101155[esp+48], edx
	lea	ecx, DWORD PTR [eax+1]
	mov	DWORD PTR _nSrcMpsY$101156[esp+48], edx
	mov	DWORD PTR _nDesMpsX$101157[esp+48], edx
	mov	DWORD PTR _nDesMpsY$101158[esp+48], edx
	mov	DWORD PTR [esi+392], ecx
	jl	$L101111

; 769  : 			{
; 770  : 				m_nParam1 = 0;
; 771  : 				if (m_nFollowNpcIdx > 0 && Npc[m_nFollowNpcIdx].IsMatch(m_dwFollowNpcID))

	mov	ecx, DWORD PTR [esi+324]
	mov	DWORD PTR [esi+392], edx
	cmp	ecx, edx
	jle	$L101111
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	lea	edx, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR [esi+328]
	cmp	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[edx*4]
	jne	$L101111

; 772  : 				{					
; 773  : 					SubWorld[m_nSubWorldId].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY, m_nXOffset, m_nYOffset, &nSrcMpsX, &nSrcMpsY);

	mov	eax, DWORD PTR [esi+232]
	lea	ecx, DWORD PTR _nSrcMpsY$101156[esp+48]
	lea	edx, DWORD PTR _nSrcMpsX$101155[esp+48]
	push	ecx
	mov	ecx, DWORD PTR [esi+228]
	push	edx
	mov	edx, DWORD PTR [ebp]
	push	eax
	mov	eax, DWORD PTR [esi+216]
	push	ecx
	push	edx
	mov	ecx, DWORD PTR [edi]
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	edx, eax
	push	ecx
	shl	edx, 6
	sub	edx, eax
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4]
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 774  : 					SubWorld[m_nSubWorldId].Map2Mps(Npc[m_nFollowNpcIdx].m_RegionIndex, Npc[m_nFollowNpcIdx].m_MapX, Npc[m_nFollowNpcIdx].m_MapY, Npc[m_nFollowNpcIdx].m_OffX, Npc[m_nFollowNpcIdx].m_OffY, &nDesMpsX, &nDesMpsY);

	mov	ecx, DWORD PTR [esi+324]
	lea	edx, DWORD PTR _nDesMpsX$101157[esp+48]
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	lea	ecx, DWORD PTR _nDesMpsY$101158[esp+48]
	push	ecx
	push	edx
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3128]
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3124]
	push	ecx
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3116]
	push	edx
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3112]
	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+2608]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, eax
	shl	ecx, 6
	sub	ecx, eax
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4]
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 775  : 					nDistance = SubWorld[m_nSubWorldId].GetDistance(nSrcMpsX, nSrcMpsY, nDesMpsX, nDesMpsY);

	mov	edx, DWORD PTR _nDesMpsY$101158[esp+48]
	mov	eax, DWORD PTR _nDesMpsX$101157[esp+48]
	mov	ecx, DWORD PTR _nSrcMpsY$101156[esp+48]
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	edx, DWORD PTR _nSrcMpsX$101155[esp+56]
	push	ecx
	mov	ecx, eax
	push	edx
	shl	ecx, 6
	sub	ecx, eax
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4]
	call	?GetDistance@KSubWorld@@QAEHHHHH@Z	; KSubWorld::GetDistance
	mov	ebx, eax

; 776  : 				
; 777  : 					if (nDistance != 0)

	test	ebx, ebx
	je	$L101111

; 778  : 					{
; 779  : 							m_nDir = g_GetDirIndex ( nSrcMpsX, nSrcMpsY, nDesMpsX, nDesMpsY);

	mov	edx, DWORD PTR _nSrcMpsX$101155[esp+48]
	mov	ecx, DWORD PTR _nDesMpsX$101157[esp+48]
	or	eax, -1
	cmp	edx, ecx
	mov	DWORD PTR _nRet$106149[esp+48], eax
	jne	SHORT $L106150
	mov	ecx, DWORD PTR _nSrcMpsY$101156[esp+48]
	mov	edx, DWORD PTR _nDesMpsY$101158[esp+48]
	cmp	ecx, edx
	je	$L106148
$L106150:
	mov	eax, DWORD PTR _nSrcMpsY$101156[esp+48]
	mov	ecx, DWORD PTR _nDesMpsY$101158[esp+48]
	mov	edx, DWORD PTR _nDesMpsX$101157[esp+48]
	sub	eax, ecx
	mov	ecx, DWORD PTR _nSrcMpsX$101155[esp+48]
	sub	ecx, edx
	mov	edx, ecx
	imul	edx, ecx
	mov	ecx, eax
	imul	ecx, eax
	add	edx, ecx
	mov	DWORD PTR -8+[esp+48], edx
	xor	edx, edx
	fild	DWORD PTR -8+[esp+48]
	fstp	DWORD PTR _fi$106143[esp+48]
	mov	eax, DWORD PTR _fi$106143[esp+48]
	mov	dl, BYTE PTR _fi$106143[esp+50]
	shr	eax, 1
	mov	ecx, DWORD PTR _sqrttable[edx*4]
	and	eax, 1065353216				; 3f800000H
	add	ecx, eax
	mov	eax, DWORD PTR _bias
	mov	DWORD PTR _fi$106143[esp+48], ecx
	fld	DWORD PTR _fi$106143[esp+48]
	fadd	DWORD PTR _bias
	fstp	DWORD PTR _tmp$106147[esp+48]
	mov	ecx, DWORD PTR _tmp$106147[esp+48]
	sub	ecx, eax
	jne	SHORT $L106152
	or	eax, -1
	jmp	SHORT $L106148
$L106152:
	mov	eax, DWORD PTR _nDesMpsY$101158[esp+48]
	mov	edx, DWORD PTR _nSrcMpsY$101156[esp+48]
	sub	eax, edx
	shl	eax, 10					; 0000000aH
	cdq
	idiv	ecx
	cmp	eax, 1024				; 00000400H
	jle	SHORT $L106155
	mov	eax, 1024				; 00000400H
	jmp	SHORT $L106157
$L106155:
	cmp	eax, -1024				; fffffc00H
	jge	SHORT $L106157
	mov	eax, -1024				; fffffc00H
$L106157:
	mov	edx, DWORD PTR ?g_nSin@@3PAHA		; g_nSin
	xor	ecx, ecx
$L106159:
	cmp	eax, DWORD PTR [edx]
	jg	SHORT $L106166
	mov	DWORD PTR _nRet$106149[esp+48], ecx
	inc	ecx
	add	edx, 4
	cmp	ecx, 32					; 00000020H
	jl	SHORT $L106159
$L106166:
	mov	edx, DWORD PTR _nDesMpsX$101157[esp+48]
	mov	ecx, DWORD PTR _nSrcMpsX$101155[esp+48]
	sub	edx, ecx
	test	edx, edx
	jle	SHORT $L106176
	mov	ecx, DWORD PTR _nRet$106149[esp+48]
	mov	eax, 63					; 0000003fH
	sub	eax, ecx
	jmp	SHORT $L106148
$L106176:
	mov	eax, DWORD PTR _nRet$106149[esp+48]
$L106148:

; 780  : 							int nXFactor = ((nDesMpsX - nSrcMpsX ) << 10) / nDistance;
; 781  : 							int nYFactor = ((nDesMpsY - nSrcMpsY ) << 10) / nDistance;
; 782  : 							m_nXFactor		 = nXFactor;

	mov	edx, DWORD PTR _nSrcMpsX$101155[esp+48]
	mov	DWORD PTR [esi+424], eax
	mov	eax, DWORD PTR _nDesMpsX$101157[esp+48]
	sub	eax, edx
	shl	eax, 10					; 0000000aH
	cdq
	idiv	ebx

; 783  : 							m_nYFactor		 = nYFactor;	

	mov	edx, DWORD PTR _nSrcMpsY$101156[esp+48]
	mov	DWORD PTR [esi+312], eax
	mov	eax, DWORD PTR _nDesMpsY$101158[esp+48]
	sub	eax, edx
	shl	eax, 10					; 0000000aH
	cdq
	idiv	ebx
	mov	DWORD PTR [esi+316], eax
$L101111:

; 784  : 					}
; 785  : 					
; 786  : 					
; 787  : 				}
; 788  : 			}
; 789  : 			nDOffsetX	 = m_nXFactor * m_nSpeed;
; 790  : 			nDOffsetY	 = m_nYFactor * m_nSpeed;
; 791  : 			
; 792  : 		}
; 793  : 		break;
; 794  : 		
; 795  : 	case	MISSLE_MMK_Motion:							//	
; 796  : 		{
; 797  : 			
; 798  : 		}break;
; 799  : 		
; 800  : 	case MISSLE_MMK_SingleLine:						//	
; 801  : 		{
; 802  : 			//			
; 803  : #ifdef _SERVER
; 804  : 			
; 805  : #else
; 806  : 			int x = m_nXOffset;
; 807  : 			int y = m_nYOffset;
; 808  : 			int dx = (m_nSpeed * m_nXFactor);

	mov	edx, DWORD PTR [esi+96]
	mov	eax, DWORD PTR [esi+312]

; 809  : 			int dy = (m_nSpeed * m_nYFactor);

	mov	ecx, DWORD PTR [esi+316]
	imul	eax, edx
	imul	ecx, edx
$L101170:

; 810  : 			nDOffsetX	=  dx;//* m_nCurrentLife;
; 811  : 			nDOffsetY	=  dy;//* m_nCurrentLife;
; 812  : 			
; 813  : #endif
; 814  : 		}
; 815  : 		break;
; 816  : 	default:
; 817  : 		_ASSERT(0);
; 818  : 		
; 819  : 	}
; 820  : 	
; 821  : 	//
; 822  : 	if (CheckBeyondRegion(nDOffsetX, nDOffsetY))

	push	ecx
	push	eax
	mov	ecx, esi
	call	?CheckBeyondRegion@KMissle@@AAEHHH@Z	; KMissle::CheckBeyondRegion
	test	eax, eax
	je	SHORT $L101172

; 823  : 	{
; 824  : 		if (CheckCollision() == -1) 

	mov	ecx, esi
	call	?CheckCollision@KMissle@@AAEHXZ		; KMissle::CheckCollision
	cmp	eax, -1
	jne	SHORT $L101177

; 825  : 		{
; 826  : 			if (m_bAutoExplode)

	mov	eax, DWORD PTR [esi+112]
	xor	ebx, ebx
	cmp	eax, ebx
	je	SHORT $L101174

; 827  : 			{
; 828  : 				ProcessCollision();//

	mov	ecx, esi
	call	?ProcessCollision@KMissle@@AAEHXZ	; KMissle::ProcessCollision
$L101174:

; 829  : 			}
; 830  : #ifndef _SERVER 
; 831  : 			int nSrcX4 = 0 ;
; 832  : 			int nSrcY4 = 0 ;
; 833  : 			SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX4, &nSrcY4);

	mov	edx, DWORD PTR [esi+232]
	lea	eax, DWORD PTR _nSrcY4$101176[esp+48]
	lea	ecx, DWORD PTR _nSrcX4$101175[esp+48]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	push	ecx
	mov	ecx, DWORD PTR [ebp]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [edi]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET FLAT:?SubWorld@@3PAVKSubWorld@@A
	mov	DWORD PTR _nSrcX4$101175[esp+76], ebx
	mov	DWORD PTR _nSrcY4$101176[esp+76], ebx
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 834  : 			CreateSpecialEffect(MS_DoVanish, nSrcX4, nSrcY4, m_nCurrentMapZ);

	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY4$101176[esp+48]
	mov	eax, DWORD PTR _nSrcX4$101175[esp+48]
	push	ebx
	push	ecx
	push	edx
$L106180:
	push	eax
$L106179:
	push	2
	mov	ecx, esi
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
$L101172:

; 835  : #endif
; 836  : 			DoVanish();
; 837  : 			return;
; 838  : 		}
; 839  : 	}
; 840  : 	else//Region
; 841  : 	{
; 842  : 		DoVanish();

	mov	ecx, esi
	call	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
$L101177:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 843  : 	}
; 844  : }

	add	esp, 32					; 00000020H
	ret	0
	npad	2
$L106182:
	DD	$L101111
	DD	$L101117
	DD	$L101139
	DD	$L101153
	DD	$L101112
	DD	$L101170
$L106181:
	DB	0
	DB	5
	DB	1
	DB	2
	DB	3
	DB	5
	DB	0
	DB	0
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	4
?OnFly@KMissle@@AAEXXZ ENDP				; KMissle::OnFly
_TEXT	ENDS
PUBLIC	??_GKWorldMsgNode@@UAEPAXI@Z			; KWorldMsgNode::`scalar deleting destructor'
PUBLIC	??_EKWorldMsgNode@@UAEPAXI@Z			; KWorldMsgNode::`vector deleting destructor'
PUBLIC	??_7KWorldMsgNode@@6B@				; KWorldMsgNode::`vftable'
EXTRN	??2@YAPAXI@Z:NEAR				; operator new
;	COMDAT ??_7KWorldMsgNode@@6B@
; File ..\engine\src\KNode.h
CONST	SEGMENT
??_7KWorldMsgNode@@6B@ DD FLAT:??_EKWorldMsgNode@@UAEPAXI@Z ; KWorldMsgNode::`vftable'
CONST	ENDS
;	COMDAT ?Send@KWorldMsg@@QAEHKHHH@Z
_TEXT	SEGMENT
_dwMsgType$ = 8
_nParam1$ = 12
_nParam2$ = 16
_nParam3$ = 20
?Send@KWorldMsg@@QAEHKHHH@Z PROC NEAR			; KWorldMsg::Send, COMDAT

; 71   : {

	push	esi
	mov	esi, ecx

; 72   : 	KWorldMsgNode *pNode = NULL;
; 73   : 
; 74   : 	pNode = new KWorldMsgNode;

	push	28					; 0000001cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $L106214

; 77   : 
; 78   : 	pNode->m_dwMsgType	= dwMsgType;

	mov	ecx, DWORD PTR _dwMsgType$[esp]

; 79   : 	pNode->m_nParam[0]	= nParam1;

	mov	edx, DWORD PTR _nParam1$[esp]
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax], OFFSET FLAT:??_7KWorldMsgNode@@6B@ ; KWorldMsgNode::`vftable'
	mov	DWORD PTR [eax+12], ecx

; 80   : 	pNode->m_nParam[1]	= nParam2;

	mov	ecx, DWORD PTR _nParam2$[esp]
	mov	DWORD PTR [eax+16], edx

; 81   : 	pNode->m_nParam[2]	= nParam3;

	mov	edx, DWORD PTR _nParam3$[esp]
	mov	DWORD PTR [eax+20], ecx

; 82   : 
; 83   : 	m_LocalMsgQueue.AddTail(pNode);

	lea	ecx, DWORD PTR [esi+12]
	mov	DWORD PTR [eax+24], edx
	mov	edx, DWORD PTR [ecx+8]
	test	edx, edx
	je	SHORT $L106213
	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+4], ecx
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+4], eax
	mov	DWORD PTR [ecx+8], eax
$L106213:

; 84   : 	return TRUE;

	mov	eax, 1
	pop	esi

; 85   : }

	ret	16					; 00000010H
$L106214:

; 75   : 	if (!pNode)
; 76   : 		return FALSE;

	xor	eax, eax
	pop	esi

; 85   : }

	ret	16					; 00000010H
?Send@KWorldMsg@@QAEHKHHH@Z ENDP			; KWorldMsg::Send
_TEXT	ENDS
PUBLIC	??1KWorldMsgNode@@UAE@XZ			; KWorldMsgNode::~KWorldMsgNode
;	COMDAT ??_GKWorldMsgNode@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GKWorldMsgNode@@UAEPAXI@Z PROC NEAR			; KWorldMsgNode::`scalar deleting destructor', COMDAT
	push	esi
	mov	esi, ecx
	call	??1KWorldMsgNode@@UAE@XZ		; KWorldMsgNode::~KWorldMsgNode
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L106218
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L106218:
	mov	eax, esi
	pop	esi
	ret	4
??_GKWorldMsgNode@@UAEPAXI@Z ENDP			; KWorldMsgNode::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1KWorldMsgNode@@UAE@XZ
_TEXT	SEGMENT
??1KWorldMsgNode@@UAE@XZ PROC NEAR			; KWorldMsgNode::~KWorldMsgNode, COMDAT
	mov	DWORD PTR [ecx], OFFSET FLAT:??_7KNode@@6B@ ; KNode::`vftable'
	ret	0
??1KWorldMsgNode@@UAE@XZ ENDP				; KWorldMsgNode::~KWorldMsgNode
_TEXT	ENDS
;	COMDAT ?OnVanish@KMissle@@AAEXXZ
_TEXT	SEGMENT
?OnVanish@KMissle@@AAEXXZ PROC NEAR			; KMissle::OnVanish, COMDAT

; 854  : 	
; 855  : }

	ret	0
?OnVanish@KMissle@@AAEXXZ ENDP				; KMissle::OnVanish
_TEXT	ENDS
PUBLIC	?Paint@KMissle@@QAEXXZ				; KMissle::Paint
EXTRN	?Draw@KMissleRes@@QAEHHHHHHHH@Z:NEAR		; KMissleRes::Draw
;	COMDAT ?Paint@KMissle@@QAEXXZ
_TEXT	SEGMENT
_fi$106280 = -8
_tmp$106284 = -8
_nSrcX$ = -12
_nSrcY$ = -16
?Paint@KMissle@@QAEXXZ PROC NEAR			; KMissle::Paint, COMDAT

; 859  : {

	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx
	push	edi

; 860  : 	if (m_nMissleId <= 0 ) return;

	mov	eax, DWORD PTR [esi+356]
	test	eax, eax
	jle	$L101191

; 861  : 	int nSrcX;
; 862  : 	int nSrcY;
; 863  : 	SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX, &nSrcY);

	mov	edx, DWORD PTR [esi+232]
	lea	eax, DWORD PTR _nSrcY$[esp+24]
	lea	ecx, DWORD PTR _nSrcX$[esp+24]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET FLAT:?SubWorld@@3PAVKSubWorld@@A
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 864  : 	
; 865  : 	if (!m_nZAcceleration)

	mov	eax, DWORD PTR [esi+348]
	test	eax, eax
	jne	SHORT $L101187

; 866  : 	{
; 867  : 		m_MissleRes.Draw(m_eMissleStatus, nSrcX, nSrcY, m_nCurrentMapZ, m_nDir,m_nLifeTime - m_nStartLifeTime,  m_nCurrentLife - m_nStartLifeTime );

	mov	eax, DWORD PTR [esi+208]
	mov	ecx, DWORD PTR [esi+204]
	mov	edx, DWORD PTR [esi+92]
	sub	ecx, eax
	sub	edx, eax
	mov	eax, DWORD PTR [esi+424]
	push	ecx
	mov	ecx, DWORD PTR [esi+224]
	push	edx
	mov	edx, DWORD PTR _nSrcY$[esp+32]
	push	eax
	mov	eax, DWORD PTR _nSrcX$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [esi+352]
	push	edx
	lea	edi, DWORD PTR [esi+472]
	push	eax
	push	ecx
	mov	ecx, edi
	call	?Draw@KMissleRes@@QAEHHHHHHHH@Z		; KMissleRes::Draw

; 868  : 	}
; 869  : 	else

	jmp	$L101188
$L101187:

; 870  : 	{
; 871  : 		int nDirIndex = g_GetDirIndex(0,0,m_nXFactor, m_nYFactor);

	mov	eax, DWORD PTR [esi+316]
	push	ebx
	mov	ebx, DWORD PTR [esi+312]
	or	edi, -1
	test	ebx, ebx
	jne	SHORT $L106287
	test	eax, eax
	jne	SHORT $L106287
	or	eax, -1
	jmp	$L106285
$L106287:
	mov	edx, ebx
	mov	ecx, eax
	imul	edx, ebx
	imul	ecx, eax
	add	edx, ecx
	mov	DWORD PTR -8+[esp+28], edx
	xor	edx, edx
	fild	DWORD PTR -8+[esp+28]
	fstp	DWORD PTR _fi$106280[esp+28]
	mov	ecx, DWORD PTR _fi$106280[esp+28]
	mov	dl, BYTE PTR _fi$106280[esp+30]
	shr	ecx, 1
	mov	edx, DWORD PTR _sqrttable[edx*4]
	and	ecx, 1065353216				; 3f800000H
	add	edx, ecx
	mov	DWORD PTR _fi$106280[esp+28], edx
	mov	edx, DWORD PTR _bias
	fld	DWORD PTR _fi$106280[esp+28]
	fadd	DWORD PTR _bias
	fstp	DWORD PTR _tmp$106284[esp+28]
	mov	ecx, DWORD PTR _tmp$106284[esp+28]
	sub	ecx, edx
	jne	SHORT $L106289
	or	eax, -1
	jmp	SHORT $L106285
$L106289:
	shl	eax, 10					; 0000000aH
	cdq
	idiv	ecx
	cmp	eax, 1024				; 00000400H
	jle	SHORT $L106292
	mov	eax, 1024				; 00000400H
	jmp	SHORT $L106294
$L106292:
	cmp	eax, -1024				; fffffc00H
	jge	SHORT $L106294
	mov	eax, -1024				; fffffc00H
$L106294:
	mov	edx, DWORD PTR ?g_nSin@@3PAHA		; g_nSin
	xor	ecx, ecx
$L106296:
	cmp	eax, DWORD PTR [edx]
	jg	SHORT $L106332
	mov	edi, ecx
	inc	ecx
	add	edx, 4
	cmp	ecx, 32					; 00000020H
	jl	SHORT $L106296
$L106332:
	test	ebx, ebx
	jle	SHORT $L106300
	mov	eax, 63					; 0000003fH
	sub	eax, edi
	mov	edi, eax
$L106300:
	mov	eax, edi
$L106285:

; 872  : 		int nDir = g_DirIndex2Dir(nDirIndex, 64);
; 873  : 		m_MissleRes.Draw(m_eMissleStatus, nSrcX, nSrcY, m_nCurrentMapZ, nDir,m_nLifeTime - m_nStartLifeTime,  m_nCurrentLife - m_nStartLifeTime );

	mov	ecx, DWORD PTR [esi+208]
	mov	edx, DWORD PTR [esi+204]
	sub	edx, ecx
	lea	edi, DWORD PTR [esi+472]
	push	edx
	mov	edx, DWORD PTR [esi+92]
	shl	eax, 6
	sub	edx, ecx
	mov	ecx, DWORD PTR _nSrcY$[esp+32]
	sar	eax, 6
	push	edx
	mov	edx, DWORD PTR _nSrcX$[esp+36]
	push	eax
	mov	eax, DWORD PTR [esi+224]
	push	eax
	mov	eax, DWORD PTR [esi+352]
	push	ecx
	push	edx
	push	eax
	mov	ecx, edi
	call	?Draw@KMissleRes@@QAEHHHHHHHH@Z		; KMissleRes::Draw
	pop	ebx
$L101188:

; 874  : 	}
; 875  : 	
; 876  : 	//!
; 877  : 	if (m_MissleRes.m_bHaveEnd && (m_MissleRes.SpecialMovieIsAllEnd()))

	mov	eax, DWORD PTR [esi+496]
	test	eax, eax
	je	SHORT $L101191
	mov	edi, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+4]
	test	eax, eax
	je	SHORT $L106322
	test	edi, edi
	jne	SHORT $L101191
$L106322:

; 878  : 		SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_DEL, m_nMissleId);

	mov	ecx, DWORD PTR [esi+356]
	mov	esi, DWORD PTR [esi+360]
	mov	edx, esi
	push	0
	shl	edx, 6
	sub	edx, esi
	push	0
	push	ecx
	push	4001					; 00000fa1H
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+204]
	call	?Send@KWorldMsg@@QAEHKHHH@Z		; KWorldMsg::Send
$L101191:
	pop	edi
	pop	esi

; 879  : }

	add	esp, 16					; 00000010H
	ret	0
?Paint@KMissle@@QAEXXZ ENDP				; KMissle::Paint
_TEXT	ENDS
;	COMDAT ?CheckBeyondRegion@KMissle@@AAEHHH@Z
_TEXT	SEGMENT
_nDOffsetX$ = 8
_nDOffsetY$ = 12
_nOldRegion$ = -4
_nNewYOffset$ = 12
_nNewMapY$ = 8
?CheckBeyondRegion@KMissle@@AAEHHH@Z PROC NEAR		; KMissle::CheckBeyondRegion, COMDAT

; 884  : {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 885  : 	if (m_nRegionId < 0) 

	mov	edi, DWORD PTR [esi+364]
	test	edi, edi
	jge	SHORT $L101197
	pop	edi
	pop	esi
	pop	ebp

; 886  : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 988  : }

	pop	ecx
	ret	8
$L101197:

; 887  : 	//
; 888  : 	if (nDOffsetX == 0 && nDOffsetY == 0) return TRUE;

	mov	ecx, DWORD PTR _nDOffsetX$[esp+16]
	mov	ebp, DWORD PTR _nDOffsetY$[esp+16]
	test	ecx, ecx
	jne	SHORT $L101198
	test	ebp, ebp
	je	$L101228
$L101198:

; 889  : 
; 890  : 	if (abs(nDOffsetX) > CellWidth) 

	mov	eax, ecx
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 32768				; 00008000H
	jle	SHORT $L101199
	pop	edi
	pop	esi
	pop	ebp

; 891  : 	{
; 892  : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 988  : }

	pop	ecx
	ret	8
$L101199:

; 893  : 	}
; 894  : 
; 895  : 	if (abs(nDOffsetY) > CellHeight) 

	mov	eax, ebp
	cdq
	xor	eax, edx
	sub	eax, edx
	cmp	eax, 32768				; 00008000H
	jle	SHORT $L101200
	pop	edi
	pop	esi
	pop	ebp

; 896  : 	{
; 897  : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 988  : }

	pop	ecx
	ret	8
$L101200:

; 898  : 	}
; 899  : 
; 900  : 	int nOldRegion		= m_nRegionId;
; 901  : 	int nNewXOffset		= m_nXOffset + nDOffsetX;

	mov	ebx, DWORD PTR [esi+228]

; 902  : 	int nNewYOffset		= m_nYOffset + nDOffsetY;

	mov	eax, DWORD PTR [esi+232]
	add	ebx, ecx

; 903  : 	int nNewMapX		= m_nCurrentMapX;
; 904  : 	int nNewMapY		= m_nCurrentMapY;

	mov	ecx, DWORD PTR [esi+220]
	add	eax, ebp
	mov	ebp, DWORD PTR [esi+216]

; 905  : 	int nNewRegion		= m_nRegionId;
; 906  : 	
; 907  : 	DWORD nRegionWidth = RegionWidth;
; 908  : 	DWORD nRegionHeight = RegionHeight;
; 909  : 	
; 910  : 	_ASSERT(abs(nNewXOffset) <= CellWidth * 2);
; 911  : 	_ASSERT(abs(nNewYOffset) <= CellHeight * 2);
; 912  : 	
; 913  : 	//	NPC
; 914  : 	//	CELLWIDTHCELLHEIGHTOffXOffY1024
; 915  : 	
; 916  : 	if (nNewXOffset < 0)

	test	ebx, ebx
	mov	DWORD PTR _nOldRegion$[esp+20], edi
	mov	DWORD PTR _nNewYOffset$[esp+16], eax
	mov	DWORD PTR _nNewMapY$[esp+16], ecx
	jge	SHORT $L101211

; 917  : 	{
; 918  : 		nNewMapX--;

	dec	ebp

; 919  : 		nNewXOffset += CellWidth;

	add	ebx, 32768				; 00008000H

; 920  : 	}
; 921  : 	else if (nNewXOffset > CellWidth)

	jmp	SHORT $L101213
$L101211:
	cmp	ebx, 32768				; 00008000H
	jle	SHORT $L101213

; 922  : 	{
; 923  : 		nNewMapX++;

	inc	ebp

; 924  : 		nNewXOffset -= CellWidth;

	sub	ebx, 32768				; 00008000H
$L101213:

; 925  : 	}
; 926  : 	
; 927  : 	if (nNewYOffset < 0)

	test	eax, eax
	jge	SHORT $L101214

; 928  : 	{
; 929  : 		nNewMapY--;

	dec	ecx

; 930  : 		nNewYOffset += CellHeight;

	add	eax, 32768				; 00008000H
	mov	DWORD PTR _nNewMapY$[esp+16], ecx

; 931  : 	}
; 932  : 	else if (nNewYOffset > CellHeight)

	jmp	SHORT $L106339
$L101214:
	cmp	eax, 32768				; 00008000H
	jle	SHORT $L101216

; 933  : 	{
; 934  : 		nNewMapY++;

	inc	ecx

; 935  : 		nNewYOffset -= CellHeight;

	sub	eax, 32768				; 00008000H
	mov	DWORD PTR _nNewMapY$[esp+16], ecx
$L106339:
	mov	DWORD PTR _nNewYOffset$[esp+16], eax
$L101216:

; 936  : 	}
; 937  : 	
; 938  : 	if (nNewMapX < 0)

	test	ebp, ebp
	jge	SHORT $L101217

; 939  : 	{
; 940  : 		nNewRegion = LeftRegion(m_nRegionId);

	mov	eax, DWORD PTR [esi+360]
	mov	edx, eax
	shl	edx, 6
	sub	edx, eax
	mov	eax, DWORD PTR [esi+364]
	mov	edx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+40]
	lea	edi, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+edi*4]
	shl	eax, 4

; 941  : 		nNewMapX += nRegionWidth;

	add	ebp, 16					; 00000010H
	mov	edi, DWORD PTR [edx+eax+112]

; 942  : 	}
; 943  : 	else if ((DWORD)nNewMapX >= nRegionWidth)

	jmp	SHORT $L101220
$L101217:
	cmp	ebp, 16					; 00000010H
	jb	SHORT $L101220

; 944  : 	{
; 945  : 		nNewRegion = RightRegion(m_nRegionId);

	mov	eax, DWORD PTR [esi+360]
	mov	edx, eax
	shl	edx, 6
	sub	edx, eax
	mov	eax, DWORD PTR [esi+364]
	mov	edx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+40]
	lea	edi, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+edi*4]
	shl	eax, 4

; 946  : 		nNewMapX -= nRegionWidth;

	sub	ebp, 16					; 00000010H
	mov	edi, DWORD PTR [edx+eax+128]
$L101220:

; 947  : 	}
; 948  : 
; 949  : 	if (nNewRegion < 0) 

	test	edi, edi
	jge	SHORT $L101221
	pop	edi
	pop	esi
	pop	ebp

; 950  : 	{
; 951  : 		return FALSE; 

	xor	eax, eax
	pop	ebx

; 988  : }

	pop	ecx
	ret	8
$L101221:

; 952  : 	}
; 953  : 	
; 954  : 	if (nNewMapY < 0)

	test	ecx, ecx
	jge	SHORT $L101222

; 955  : 	{
; 956  : 		nNewRegion = UpRegion(nNewRegion);

	mov	eax, DWORD PTR [esi+360]
	mov	edx, eax
	shl	edx, 6
	sub	edx, eax
	lea	eax, DWORD PTR [edi+edi*2]
	mov	edx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+40]
	lea	eax, DWORD PTR [edi+eax*4]
	shl	eax, 4

; 957  : 		nNewMapY += nRegionHeight;

	add	ecx, 32					; 00000020H
	mov	edi, DWORD PTR [edx+eax+120]

; 958  : 	}
; 959  : 	else if (nNewMapY >= RegionHeight)

	jmp	SHORT $L106340
$L101222:
	cmp	ecx, 32					; 00000020H
	jl	SHORT $L101224

; 960  : 	{
; 961  : 		nNewRegion = DownRegion(nNewRegion);

	mov	eax, DWORD PTR [esi+360]
	mov	edx, eax
	shl	edx, 6
	sub	edx, eax
	lea	eax, DWORD PTR [edi+edi*2]
	mov	edx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+40]
	lea	eax, DWORD PTR [edi+eax*4]
	shl	eax, 4

; 962  : 		nNewMapY -= nRegionHeight;

	sub	ecx, 32					; 00000020H
	mov	edi, DWORD PTR [edx+eax+104]
$L106340:
	mov	DWORD PTR _nNewMapY$[esp+16], ecx
$L101224:

; 963  : 	}
; 964  : 	
; 965  : 	//
; 966  : 	if (nNewRegion < 0) 

	test	edi, edi
	jge	SHORT $L101225
	pop	edi
	pop	esi
	pop	ebp

; 967  : 	{
; 968  : 		return FALSE; 

	xor	eax, eax
	pop	ebx

; 988  : }

	pop	ecx
	ret	8
$L101225:

; 969  : 	}
; 970  : 	else
; 971  : 	{
; 972  : 		CurRegion.DecRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	eax, DWORD PTR [esi+220]
	push	2
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, DWORD PTR [esi+216]
	mov	edx, eax
	shl	edx, 6
	sub	edx, eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+40]
	shl	eax, 4
	add	ecx, eax
	call	?DecRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::DecRef

; 973  : 		_ASSERT(m_nCurrentMapX >= 0  &&  m_nCurrentMapY >= 0);
; 974  : 		
; 975  : 		m_nRegionId	   = nNewRegion;
; 976  : 		m_nCurrentMapX = nNewMapX;
; 977  : 		m_nCurrentMapY = nNewMapY;

	mov	eax, DWORD PTR _nNewMapY$[esp+16]

; 978  : 		m_nXOffset	   = nNewXOffset;
; 979  : 		m_nYOffset	   = nNewYOffset;
; 980  : 		CurRegion.AddRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	push	2
	mov	DWORD PTR [esi+220], eax
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, DWORD PTR _nNewYOffset$[esp+24]
	mov	edx, eax
	mov	DWORD PTR [esi+364], edi
	shl	edx, 6
	sub	edx, eax
	lea	eax, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+216], ebp
	mov	DWORD PTR [esi+228], ebx
	lea	eax, DWORD PTR [edi+eax*4]
	mov	DWORD PTR [esi+232], ecx
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+40]
	push	ebp
	shl	eax, 4
	add	ecx, eax
	call	?AddRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::AddRef

; 981  : 		
; 982  : 		if (nOldRegion != m_nRegionId)

	mov	eax, DWORD PTR [esi+364]
	mov	ecx, DWORD PTR _nOldRegion$[esp+20]
	cmp	ecx, eax
	je	SHORT $L101228

; 983  : 		{
; 984  : 			SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_CHANGE_REGION, nOldRegion, m_nRegionId, m_nMissleId);

	mov	edx, DWORD PTR [esi+356]
	mov	esi, DWORD PTR [esi+360]
	push	edx
	push	eax
	mov	eax, esi
	push	ecx
	shl	eax, 6
	sub	eax, esi
	push	4002					; 00000fa2H
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax*4+204]
	call	?Send@KWorldMsg@@QAEHKHHH@Z		; KWorldMsg::Send
$L101228:
	pop	edi
	pop	esi
	pop	ebp

; 985  : 		}
; 986  : 	}
; 987  : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 988  : }

	pop	ecx
	ret	8
?CheckBeyondRegion@KMissle@@AAEHHH@Z ENDP		; KMissle::CheckBeyondRegion
_TEXT	ENDS
PUBLIC	??4KMissle@@AAEAAV0@AAV0@@Z			; KMissle::operator=
EXTRN	__imp_?g_Random@@YAII@Z:NEAR
;	COMDAT ??4KMissle@@AAEAAV0@AAV0@@Z
_TEXT	SEGMENT
_Missle$ = 8
??4KMissle@@AAEAAV0@AAV0@@Z PROC NEAR			; KMissle::operator=, COMDAT

; 991  : {

	sub	esp, 8
	push	ebx

; 992  : 	Missle.m_nTempParam1	=	0;

	mov	ebx, DWORD PTR _Missle$[esp+8]
	xor	edx, edx
	push	ebp
	mov	DWORD PTR [ebx+412], edx

; 993  : 	Missle.m_nTempParam2	=	0;

	mov	DWORD PTR [ebx+416], edx

; 994  : 	Missle.m_nDesMapX			=	0;

	mov	DWORD PTR [ebx+244], edx

; 995  : 	Missle.m_nDesMapY			=	0;

	mov	DWORD PTR [ebx+248], edx
	mov	ebp, ecx

; 996  : 	Missle.m_nDesRegion		=	0;

	mov	DWORD PTR [ebx+252], edx
	push	esi

; 997  : 	Missle.m_bNeedReclaim	=	FALSE;

	mov	DWORD PTR [ebx+256], edx
	push	edi

; 998  : 	Missle.m_nFirstReclaimTime = 0;

	mov	DWORD PTR [ebx+404], edx

; 999  : 	Missle.m_nEndReclaimTime = 0;
; 1000 : 	memset(Missle.m_NeedReclaimPos, 0, sizeof(m_NeedReclaimPos));

	mov	ecx, 12					; 0000000cH
	xor	eax, eax
	lea	edi, DWORD PTR [ebx+260]
	mov	DWORD PTR [ebx+408], edx
	rep stosd

; 1001 : 
; 1002 : 	Missle.m_bCanSlow		=	m_bCanSlow;

	mov	eax, DWORD PTR [ebp+160]

; 1003 : 	Missle.m_bCollideEvent	=	m_bCollideEvent;
; 1004 : 	Missle.m_bCollideFriend =	m_bCollideFriend;
; 1005 : 	Missle.m_bCollideVanish	=	m_bCollideVanish;
; 1006 : 	Missle.m_bRangeDamage	=	m_bRangeDamage;
; 1007 : 	Missle.m_eFollowKind	=	m_eFollowKind;
; 1008 : 	Missle.m_eMoveKind		=	m_eMoveKind;
; 1009 : 	Missle.m_nAction		=	m_nAction;
; 1010 : 	Missle.m_nAngle			=	m_nAngle;
; 1011 : 	Missle.m_nCollideRange	=	m_nCollideRange;
; 1012 : 	Missle.m_nCurrentLife	=	0;
; 1013 : 	Missle.m_nDamageRange	=	m_nDamageRange;
; 1014 : 	Missle.m_nHeight		=	m_nHeight;
; 1015 : 	Missle.m_nLifeTime		=	m_nLifeTime;
; 1016 : 	Missle.m_nSpeed			=   m_nSpeed;
; 1017 : 	Missle.m_nParam1		=	m_nParam1;
; 1018 : 	Missle.m_nParam2		=	m_nParam2;
; 1019 : 	Missle.m_nParam3		=	m_nParam3;
; 1020 : 	Missle.m_nCurrentMapZ	=   m_nHeight >> 10;
; 1021 : 	Missle.m_bFlyEvent		=	m_bFlyEvent;
; 1022 : 	Missle.m_nFlyEventTime  =	m_nFlyEventTime;
; 1023 : 	Missle.m_nZAcceleration =	m_nZAcceleration;
; 1024 : 	Missle.m_nHeightSpeed	=	m_nHeightSpeed;
; 1025 : 	Missle.m_bAutoExplode	=	m_bAutoExplode;
; 1026 : 	Missle.m_ulDamageInterval = m_ulDamageInterval;
; 1027 : 	strcpy(Missle.m_szMissleName	,	m_szMissleName);

	lea	edi, DWORD PTR [ebp+24]
	mov	DWORD PTR [ebx+160], eax
	mov	ecx, DWORD PTR [ebp+188]
	mov	DWORD PTR [ebx+188], ecx
	mov	eax, DWORD PTR [ebp+156]
	mov	DWORD PTR [ebx+156], eax
	mov	ecx, DWORD PTR [ebp+152]
	mov	DWORD PTR [ebx+152], ecx
	mov	eax, DWORD PTR [ebp+104]
	mov	DWORD PTR [ebx+104], eax
	mov	ecx, DWORD PTR [ebp+80]
	mov	DWORD PTR [ebx+80], ecx
	mov	eax, DWORD PTR [ebp+76]
	mov	DWORD PTR [ebx+76], eax
	mov	ecx, DWORD PTR [ebp+56]
	mov	DWORD PTR [ebx+56], ecx
	mov	eax, DWORD PTR [ebp+428]
	mov	DWORD PTR [ebx+428], eax
	mov	ecx, DWORD PTR [ebp+144]
	mov	DWORD PTR [ebx+144], ecx
	mov	DWORD PTR [ebx+204], edx
	mov	eax, DWORD PTR [ebp+148]
	lea	esi, DWORD PTR [ebx+24]
	mov	DWORD PTR [ebx+148], eax
	mov	ecx, DWORD PTR [ebp+84]
	mov	DWORD PTR [ebx+84], ecx
	mov	eax, DWORD PTR [ebp+92]
	mov	DWORD PTR [ebx+92], eax
	mov	ecx, DWORD PTR [ebp+96]
	mov	DWORD PTR [ebx+96], ecx
	mov	eax, DWORD PTR [ebp+392]
	mov	DWORD PTR [ebx+392], eax
	mov	ecx, DWORD PTR [ebp+396]
	mov	DWORD PTR [ebx+396], ecx
	mov	eax, DWORD PTR [ebp+400]
	mov	DWORD PTR [ebx+400], eax
	mov	ecx, DWORD PTR [ebp+84]
	sar	ecx, 10					; 0000000aH
	mov	DWORD PTR [ebx+224], ecx
	mov	eax, DWORD PTR [ebp+172]
	mov	DWORD PTR [ebx+172], eax
	mov	ecx, DWORD PTR [ebp+176]
	mov	DWORD PTR [ebx+176], ecx
	mov	eax, DWORD PTR [ebp+348]
	mov	DWORD PTR [ebx+348], eax
	mov	ecx, DWORD PTR [ebp+88]
	mov	DWORD PTR [ebx+88], ecx
	mov	eax, DWORD PTR [ebp+112]
	mov	DWORD PTR [ebx+112], eax
	mov	ecx, DWORD PTR [ebp+196]
	mov	DWORD PTR [ebx+196], ecx
	or	ecx, -1
	xor	eax, eax
	mov	DWORD PTR 8+[esp+20], esi
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	eax, ecx
	mov	esi, edi
	mov	edi, DWORD PTR 8+[esp+20]
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	and	ecx, 3
	rep movsb

; 1028 : 	
; 1029 : #ifndef  _SERVER
; 1030 : 	Missle.m_bMultiShow		=  m_bMultiShow;

	mov	ecx, DWORD PTR [ebp+448]
	mov	DWORD PTR [ebx+448], ecx

; 1031 : 	Missle.m_MissleRes.m_bLoopAnim = m_MissleRes.m_bLoopAnim;

	mov	eax, DWORD PTR [ebp+500]
	mov	DWORD PTR [ebx+500], eax

; 1032 : 	Missle.m_MissleRes.m_bHaveEnd = FALSE;

	mov	DWORD PTR [ebx+496], edx

; 1033 : 	Missle.m_btRedLum		= m_btRedLum;

	mov	ecx, DWORD PTR [ebp+456]
	mov	DWORD PTR [ebx+456], ecx

; 1034 : 	Missle.m_btGreenLum		= m_btGreenLum;

	mov	eax, DWORD PTR [ebp+460]
	mov	DWORD PTR [ebx+460], eax

; 1035 : 	Missle.m_btBlueLum		= m_btBlueLum;

	mov	ecx, DWORD PTR [ebp+464]
	mov	DWORD PTR [ebx+464], ecx

; 1036 : 	Missle.m_usLightRadius	= m_usLightRadius;

	mov	ax, WORD PTR [ebp+468]
	mov	WORD PTR [ebx+468], ax

; 1037 : 	int nOffset = 0;
; 1038 : 	
; 1039 : 	//
; 1040 : 	if (m_bMultiShow)		

	mov	ecx, DWORD PTR [ebp+448]
	xor	eax, eax
	cmp	ecx, edx
	je	SHORT $L101235

; 1041 : 	{
; 1042 : 		if (g_Random(2) == 0)

	push	2
	call	DWORD PTR __imp_?g_Random@@YAII@Z
	add	esp, 4
	neg	eax
	sbb	eax, eax
	and	eax, 4
$L101235:

; 1043 : 		{
; 1044 : 			nOffset = 0;
; 1045 : 		}
; 1046 : 		else
; 1047 : 			nOffset = MAX_MISSLE_STATUS;
; 1048 : 	}
; 1049 : 	
; 1050 : 	for (int t = 0; t < MAX_MISSLE_STATUS ; t++)

	lea	ecx, DWORD PTR [ebx+604]
	mov	DWORD PTR -8+[esp+24], 4
	mov	DWORD PTR 8+[esp+20], ecx
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	edx, DWORD PTR [ecx+ecx*8]
	shl	edx, 1
	sub	edx, eax
	lea	edx, DWORD PTR [ebp+edx*4+604]
$L101238:

; 1051 : 	{
; 1052 : 		strcpy(Missle.m_MissleRes.m_MissleRes[t].AnimFileName,m_MissleRes.m_MissleRes[t + nOffset].AnimFileName);

	mov	eax, DWORD PTR 8+[esp+20]
	lea	edi, DWORD PTR [edx-100]
	or	ecx, -1
	lea	esi, DWORD PTR [eax-100]
	xor	eax, eax
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	DWORD PTR -4+[esp+24], esi
	mov	eax, ecx
	mov	esi, edi
	mov	edi, DWORD PTR -4+[esp+24]
	shr	ecx, 2
	rep movsd
	mov	ecx, eax

; 1053 : 		
; 1054 : 		Missle.m_MissleRes.m_MissleRes[t].nTotalFrame = m_MissleRes.m_MissleRes[t + nOffset].nTotalFrame;

	mov	eax, DWORD PTR 8+[esp+20]
	and	ecx, 3
	rep movsb
	mov	ecx, DWORD PTR [edx]

; 1055 : 		Missle.m_MissleRes.m_MissleRes[t].nDir = m_MissleRes.m_MissleRes[t + nOffset].nDir;
; 1056 : 		Missle.m_MissleRes.m_MissleRes[t].nInterval = m_MissleRes.m_MissleRes[t + nOffset].nInterval;
; 1057 : 		
; 1058 : 		strcpy(Missle.m_MissleRes.m_MissleRes[t].SndFileName,m_MissleRes.m_MissleRes[t + nOffset].SndFileName);

	lea	esi, DWORD PTR [eax+12]
	mov	DWORD PTR [eax], ecx
	mov	ecx, DWORD PTR [edx+8]
	mov	DWORD PTR [eax+8], ecx
	mov	ecx, DWORD PTR [edx+4]
	mov	DWORD PTR [eax+4], ecx
	lea	edi, DWORD PTR [edx+12]
	or	ecx, -1
	xor	eax, eax
	repne scasb
	not	ecx
	sub	edi, ecx
	mov	DWORD PTR -4+[esp+24], esi
	mov	eax, ecx
	mov	esi, edi
	mov	edi, DWORD PTR -4+[esp+24]
	add	edx, 212				; 000000d4H
	shr	ecx, 2
	rep movsd
	mov	ecx, eax
	mov	eax, DWORD PTR -8+[esp+24]
	and	ecx, 3
	rep movsb
	mov	ecx, DWORD PTR 8+[esp+20]
	add	ecx, 212				; 000000d4H
	dec	eax
	mov	DWORD PTR 8+[esp+20], ecx
	mov	DWORD PTR -8+[esp+24], eax
	jne	$L101238

; 1059 : 	}
; 1060 : 	Missle.m_MissleRes.m_bSubLoop = m_MissleRes.m_bSubLoop;

	mov	ecx, DWORD PTR [ebp+2252]
	pop	edi
	mov	DWORD PTR [ebx+2252], ecx

; 1061 : 	Missle.m_MissleRes.m_nSubStart = m_MissleRes.m_nSubStart;

	mov	edx, DWORD PTR [ebp+2256]
	mov	DWORD PTR [ebx+2256], edx

; 1062 : 	Missle.m_MissleRes.m_nSubStop = m_MissleRes.m_nSubStop;

	mov	eax, DWORD PTR [ebp+2260]
	mov	DWORD PTR [ebx+2260], eax
	pop	esi

; 1063 : #endif	
; 1064 : 	
; 1065 : 	return (Missle);

	mov	eax, ebx
	pop	ebp
	pop	ebx

; 1066 : }

	add	esp, 8
	ret	4
??4KMissle@@AAEAAV0@AAV0@@Z ENDP			; KMissle::operator=
_TEXT	ENDS
PUBLIC	?ProcessDamage@KMissle@@AAEHH@Z			; KMissle::ProcessDamage
;	COMDAT ?ProcessDamage@KMissle@@AAEHH@Z
_TEXT	SEGMENT
?ProcessDamage@KMissle@@AAEHH@Z PROC NEAR		; KMissle::ProcessDamage, COMDAT

; 1078 : #ifdef _SERVER
; 1079 : 	_ASSERT (Npc[m_nLauncher].IsMatch(m_dwLauncherId));
; 1080 : 	
; 1081 : 	if (m_pMagicAttribsData) 
; 1082 : 	{
; 1083 : 		
; 1084 : //fix tvb
; 1085 : 		int nDameXG = 0;
; 1086 : 		if (m_nSkillId == 322)//pha thien tram
; 1087 : 		{
; 1088 : 			if ((m_nDir >= 10 && m_nDir < 25) || (m_nDir >= 45 && m_nDir < 60))
; 1089 : 			{
; 1090 : 				nDameXG = 2;
; 1091 : 			}
; 1092 : 		}
; 1093 : 		else if (m_nSkillId == 323)//truy tinh truc nguyet
; 1094 : 		{
; 1095 : 			if ((m_nDir >= 10 && m_nDir < 25) || (m_nDir >= 45 && m_nDir < 60))
; 1096 : 			{
; 1097 : 				nDameXG = 2;
; 1098 : 			}
; 1099 : 		}
; 1100 : 		else if (m_nSkillId == 325)//truy phong quyet
; 1101 : 		{
; 1102 : 			if ((m_nDir >= 10 && m_nDir < 20) || (m_nDir >= 45 && m_nDir < 55))
; 1103 : 			{
; 1104 : 				nDameXG = 3;
; 1105 : 			}
; 1106 : 			else if (m_nDir == 60)
; 1107 : 			{
; 1108 : 				nDameXG = 4;
; 1109 : 			}
; 1110 : 		}
; 1111 : 		else if (m_nSkillId == 302)// Bao Vu Le Hoa
; 1112 : 		{
; 1113 : 			nDameXG = 5;
; 1114 : 		}
; 1115 : 		else if (m_nSkillId == 336)// Bang Tung vo anh
; 1116 : 		{
; 1117 : 			nDameXG = 6;
; 1118 : 		}
; 1119 : 		else if (m_nSkillId == 357)// phi long tai thien
; 1120 : 		{
; 1121 : 			nDameXG = 7;
; 1122 : 		}
; 1123 : 		else if (m_nSkillId == 359)// thien ha vo cau
; 1124 : 		{
; 1125 : 			nDameXG = 8;
; 1126 : 		}		
; 1127 : 		else if (m_nSkillId == 105)// Vu Da Le Hoa
; 1128 : 		{
; 1129 : 			nDameXG = 9;
; 1130 : 		}
; 1131 : 		else if (m_nSkillId == 328)// Tam Nga Te Tuyet
; 1132 : 		{
; 1133 : 			nDameXG = 10;
; 1134 : 		}
; 1135 : 		else if (m_nSkillId == 372)// Ngao Tuyet Tieu Phong
; 1136 : 		{
; 1137 : 			nDameXG = 11;
; 1138 : 		}
; 1139 : 		else if (m_nSkillId == 365)// Thien Dia Vo Cuc
; 1140 : 		{
; 1141 : 			nDameXG = 12;
; 1142 : 		}
; 1143 : 		else if (m_nSkillId == 368)// Nhan Kiem Hop Nhat
; 1144 : 		{
; 1145 : 			nDameXG = 13;
; 1146 : 		}
; 1147 : 		else if (m_nSkillId == 361)// Nhan Kiem Hop Nhat
; 1148 : 		{
; 1149 : 			nDameXG = 14;
; 1150 : 		}
; 1151 : //
; 1152 : 		if(m_btMissRate > 0 && m_btMissRate > m_btRandomParam)
; 1153 : 			return FALSE;
; 1154 : 		
; 1155 : 		if(Npc[nNpcId].m_ReturnSkill > 0 || Npc[nNpcId].m_IgnoreSkill > 0)
; 1156 : 		{
; 1157 : 			KSkill * pOrdinSkill = (KSkill *)g_SkillManager.GetSkill(m_nSkillId, m_nLevel);
; 1158 : 			if(!pOrdinSkill)
; 1159 : 				return FALSE;
; 1160 : 			if(pOrdinSkill->IsTargetEnemy())
; 1161 : 			{
; 1162 : 				if (pOrdinSkill->GetChildSkillId() == BUFF_SKILL_MISSLE_ID_1 ||
; 1163 : 					pOrdinSkill->GetChildSkillId() == BUFF_SKILL_MISSLE_ID_2) 
; 1164 : 				{	
; 1165 : 					if(Npc[nNpcId].m_ReturnSkill > 0 && m_btRandomParam < Npc[nNpcId].m_ReturnSkill)
; 1166 : 					{
; 1167 : 						if (Npc[m_nLauncher].ReceiveDamage(nNpcId, m_bIsMelee, m_pMagicAttribsData->m_pDamageMagicAttribs, m_bUseAttackRating, m_bDoHurt))
; 1168 : 						{
; 1169 : 							Npc[nNpcId].AutoDoSkill(725,1, -1, nNpcId);
; 1170 : 							if (m_pMagicAttribsData->m_nStateMagicAttribsNum > 0)
; 1171 : 								Npc[m_nLauncher].SetStateSkillEffect(nNpcId, m_nSkillId, m_nLevel, m_pMagicAttribsData->m_pStateMagicAttribs, m_pMagicAttribsData->m_nStateMagicAttribsNum, m_pMagicAttribsData->m_pStateMagicAttribs[0].nValue[1]);
; 1172 : 							
; 1173 : 							if (m_pMagicAttribsData->m_nImmediateMagicAttribsNum > 0)
; 1174 : 								Npc[m_nLauncher].SetImmediatelySkillEffect(nNpcId, m_pMagicAttribsData->m_pImmediateAttribs, m_pMagicAttribsData->m_nImmediateMagicAttribsNum);
; 1175 : 						}
; 1176 : 					}
; 1177 : 
; 1178 : 					if(Npc[nNpcId].m_IgnoreSkill > 0 && m_btRandomParam < Npc[nNpcId].m_IgnoreSkill)
; 1179 : 					{	
; 1180 : 						int i = 0;
; 1181 : 						for(i = 0; i < m_pMagicAttribsData->m_nStateMagicAttribsNum; i++)
; 1182 : 						{
; 1183 : 							if(m_pMagicAttribsData->m_pStateMagicAttribs[i].nAttribType != magic_poisonres_p &&
; 1184 : 								m_pMagicAttribsData->m_pStateMagicAttribs[i].nAttribType != magic_fireres_p &&
; 1185 : 								m_pMagicAttribsData->m_pStateMagicAttribs[i].nAttribType != magic_lightingres_p &&
; 1186 : 								m_pMagicAttribsData->m_pStateMagicAttribs[i].nAttribType != magic_physicsres_p &&
; 1187 : 								m_pMagicAttribsData->m_pStateMagicAttribs[i].nAttribType != magic_coldres_p &&
; 1188 : 								m_pMagicAttribsData->m_pStateMagicAttribs[i].nAttribType != magic_allres_p)
; 1189 : 								continue;
; 1190 : 							if(m_pMagicAttribsData->m_pStateMagicAttribs[i].nValue[0] < 0)
; 1191 : 							{	
; 1192 : 								Npc[nNpcId].AutoDoSkill(724,1, -1, nNpcId);
; 1193 : 								return FALSE;
; 1194 : 							}
; 1195 : 						}
; 1196 : 					}
; 1197 : 				}
; 1198 : 			}
; 1199 : 			if (Npc[nNpcId].ReceiveDamage(m_nLauncher, m_bIsMelee, m_pMagicAttribsData->m_pDamageMagicAttribs, m_bUseAttackRating, m_bDoHurt))
; 1200 : 			{
; 1201 : 				if (m_pMagicAttribsData->m_nStateMagicAttribsNum > 0)
; 1202 : 					Npc[nNpcId].SetStateSkillEffect(m_nLauncher, m_nSkillId, m_nLevel, m_pMagicAttribsData->m_pStateMagicAttribs, m_pMagicAttribsData->m_nStateMagicAttribsNum, m_pMagicAttribsData->m_pStateMagicAttribs[0].nValue[1]);
; 1203 : 				
; 1204 : 				if (m_pMagicAttribsData->m_nImmediateMagicAttribsNum > 0)
; 1205 : 					Npc[nNpcId].SetImmediatelySkillEffect(m_nLauncher, m_pMagicAttribsData->m_pImmediateAttribs, m_pMagicAttribsData->m_nImmediateMagicAttribsNum);
; 1206 : 			}
; 1207 : 			
; 1208 : 		}
; 1209 : 		else 
; 1210 : 		{
; 1211 : 			if (Npc[nNpcId].ReceiveDamage(m_nLauncher, m_bIsMelee, m_pMagicAttribsData->m_pDamageMagicAttribs, m_bUseAttackRating, m_bDoHurt,nDameXG))//fixTVB
; 1212 : 			{
; 1213 : 				if (m_pMagicAttribsData->m_nStateMagicAttribsNum > 0)
; 1214 : 					Npc[nNpcId].SetStateSkillEffect(m_nLauncher, m_nSkillId, m_nLevel, m_pMagicAttribsData->m_pStateMagicAttribs, m_pMagicAttribsData->m_nStateMagicAttribsNum, m_pMagicAttribsData->m_pStateMagicAttribs[0].nValue[1]);
; 1215 : 				
; 1216 : 				if (m_pMagicAttribsData->m_nImmediateMagicAttribsNum > 0)
; 1217 : 					Npc[nNpcId].SetImmediatelySkillEffect(m_nLauncher, m_pMagicAttribsData->m_pImmediateAttribs, m_pMagicAttribsData->m_nImmediateMagicAttribsNum);
; 1218 : 			}
; 1219 : 			else
; 1220 : 			{
; 1221 : 				Npc[nNpcId].SetStateSkillEffect(m_nLauncher, m_nSkillId, m_nLevel, 0, 0, 18);
; 1222 : 			}
; 1223 : 		}
; 1224 : 		
; 1225 : 		return TRUE;
; 1226 : 	}
; 1227 : #endif //_SERVER
; 1228 : 	return FALSE;

	xor	eax, eax

; 1229 : }

	ret	4
?ProcessDamage@KMissle@@AAEHH@Z ENDP			; KMissle::ProcessDamage
_TEXT	ENDS
EXTRN	?Vanish@KSkill@@ABEXPAVKMissle@@@Z:NEAR		; KSkill::Vanish
;	COMDAT ?DoVanish@KMissle@@AAEXXZ
_TEXT	SEGMENT
?DoVanish@KMissle@@AAEXXZ PROC NEAR			; KMissle::DoVanish, COMDAT

; 1231 : {

	push	esi
	mov	esi, ecx

; 1232 : 	if (m_eMissleStatus == MS_DoVanish) return ;

	cmp	DWORD PTR [esi+352], 2
	je	$L101254

; 1233 : 	
; 1234 : #ifndef _SERVER
; 1235 : 	m_MissleRes.m_bHaveEnd = TRUE;
; 1236 : 	m_nCollideOrVanishTime = m_nCurrentLife;

	mov	eax, DWORD PTR [esi+204]
	mov	DWORD PTR [esi+496], 1
	mov	DWORD PTR [esi+212], eax

; 1237 : #endif
; 1238 : 	if (m_bVanishedEvent)	

	mov	eax, DWORD PTR [esi+192]
	test	eax, eax
	je	SHORT $L101253

; 1239 : 	{
; 1240 : 		_ASSERT(m_nSkillId < MAX_SKILL && m_nLevel < MAX_SKILLLEVEL);
; 1241 : 		KSkill * pOrdinSkill = (KSkill *) g_SkillManager.GetSkill(m_nSkillId, m_nLevel);

	mov	eax, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [esi+320]
	cmp	eax, 2000				; 000007d0H
	jg	SHORT $L101253
	test	eax, eax
	jle	SHORT $L101253
	test	ecx, ecx
	jle	SHORT $L101253
	cmp	ecx, 64					; 00000040H
	jg	SHORT $L101253
	mov	edx, eax
	shl	edx, 6
	add	edx, ecx
	mov	edx, DWORD PTR ?g_SkillManager@@3VKSkillManager@@A[edx*4+31740]
	test	edx, edx
	je	SHORT $L106359
	mov	eax, edx
	jmp	SHORT $L106354
$L106359:
	push	ecx
	push	eax
	mov	ecx, OFFSET FLAT:?g_SkillManager@@3VKSkillManager@@A
	call	?InstanceSkill@KSkillManager@@AAEPAVISkill@@KK@Z ; KSkillManager::InstanceSkill
$L106354:

; 1242 : 		if (pOrdinSkill)

	test	eax, eax
	je	SHORT $L101253

; 1243 :         {
; 1244 : 			pOrdinSkill->Vanish(this);

	push	esi
	mov	ecx, eax
	call	?Vanish@KSkill@@ABEXPAVKMissle@@@Z	; KSkill::Vanish
$L101253:

; 1245 :         }
; 1246 : 	}
; 1247 : #ifdef _SERVER
; 1248 : 	SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_DEL, m_nMissleId);
; 1249 : 	m_eMissleStatus = MS_DoVanish;
; 1250 : 	return ;
; 1251 : #endif
; 1252 : 	m_eMissleStatus = MS_DoVanish;
; 1253 : #ifndef _SERVER 
; 1254 : 	if (m_nRegionId < 0)

	mov	eax, DWORD PTR [esi+364]
	mov	DWORD PTR [esi+352], 2
	test	eax, eax
	jge	SHORT $L101254

; 1255 : 	{
; 1256 : 		_ASSERT(0);
; 1257 : 		m_bRemoving = TRUE;

	mov	DWORD PTR [esi+68], 1
$L101254:
	pop	esi

; 1258 : 		return ;
; 1259 : 	}
; 1260 : #endif
; 1261 : }

	ret	0
?DoVanish@KMissle@@AAEXXZ ENDP				; KMissle::DoVanish
_TEXT	ENDS
;	COMDAT ?DoCollision@KMissle@@AAEXXZ
_TEXT	SEGMENT
_nSrcX$ = -4
_nSrcY$ = -8
_nSrcX5$101268 = -12
_nSrcY5$101269 = -16
?DoCollision@KMissle@@AAEXXZ PROC NEAR			; KMissle::DoCollision, COMDAT

; 1264 : {

	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx
	push	edi

; 1265 : 	if (m_eMissleStatus == MS_DoCollision) return;

	cmp	DWORD PTR [esi+352], 3
	je	$L101270

; 1266 : 	
; 1267 : #ifndef _SERVER
; 1268 : 	int nSrcX = 0 ;
; 1269 : 	int nSrcY = 0 ;
; 1270 : 	SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX, &nSrcY);

	mov	edx, DWORD PTR [esi+232]
	lea	eax, DWORD PTR _nSrcY$[esp+24]
	lea	ecx, DWORD PTR _nSrcX$[esp+24]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	xor	edi, edi
	push	edx
	push	eax
	mov	ecx, OFFSET FLAT:?SubWorld@@3PAVKSubWorld@@A
	mov	DWORD PTR _nSrcX$[esp+52], edi
	mov	DWORD PTR _nSrcY$[esp+52], edi
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 1271 : #endif
; 1272 : 	
; 1273 : 	if (m_bCollideEvent)	

	cmp	DWORD PTR [esi+188], edi
	je	SHORT $L101266

; 1274 : 	{
; 1275 : 		_ASSERT(m_nSkillId < MAX_SKILL && m_nLevel < MAX_SKILLLEVEL);
; 1276 : 		KSkill * pOrdinSkill = (KSkill *)g_SkillManager.GetSkill(m_nSkillId, m_nLevel);

	mov	eax, DWORD PTR [esi+100]
	mov	ecx, DWORD PTR [esi+320]
	cmp	eax, 2000				; 000007d0H
	jg	SHORT $L101266
	cmp	eax, edi
	jle	SHORT $L101266
	cmp	ecx, edi
	jle	SHORT $L101266
	cmp	ecx, 64					; 00000040H
	jg	SHORT $L101266
	mov	edx, eax
	shl	edx, 6
	add	edx, ecx
	mov	edx, DWORD PTR ?g_SkillManager@@3VKSkillManager@@A[edx*4+31740]
	cmp	edx, edi
	je	SHORT $L106372
	mov	eax, edx
	jmp	SHORT $L106367
$L106372:
	push	ecx
	push	eax
	mov	ecx, OFFSET FLAT:?g_SkillManager@@3VKSkillManager@@A
	call	?InstanceSkill@KSkillManager@@AAEPAVISkill@@KK@Z ; KSkillManager::InstanceSkill
$L106367:

; 1277 : 		if (pOrdinSkill)

	cmp	eax, edi
	je	SHORT $L101266

; 1278 :         {
; 1279 : 			pOrdinSkill->Collidsion(this);

	push	esi
	mov	ecx, eax
	call	?Collidsion@KSkill@@ABEXPAVKMissle@@@Z	; KSkill::Collidsion
$L101266:

; 1280 :         }
; 1281 : 	}
; 1282 : 	
; 1283 : 	if (m_bCollideVanish)

	cmp	DWORD PTR [esi+152], edi
	je	SHORT $L101267

; 1284 : 	{
; 1285 : #ifndef _SERVER
; 1286 : 		m_MissleRes.m_bHaveEnd = TRUE;
; 1287 : #endif
; 1288 : 		
; 1289 : #ifndef _SERVER 
; 1290 : 		int nSrcX5 = 0 ;
; 1291 : 		int nSrcY5 = 0 ;
; 1292 : 		SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX5, &nSrcY5);

	mov	edx, DWORD PTR [esi+232]
	lea	eax, DWORD PTR _nSrcY5$101269[esp+24]
	lea	ecx, DWORD PTR _nSrcX5$101268[esp+24]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET FLAT:?SubWorld@@3PAVKSubWorld@@A
	mov	DWORD PTR [esi+496], 1
	mov	DWORD PTR _nSrcX5$101268[esp+52], edi
	mov	DWORD PTR _nSrcY5$101269[esp+52], edi
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 1293 : 		CreateSpecialEffect(MS_DoVanish, nSrcX5, nSrcY5, m_nCurrentMapZ);

	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY5$101269[esp+24]
	mov	eax, DWORD PTR _nSrcX5$101268[esp+24]
	push	edi
	push	ecx
	push	edx
	push	eax
	push	2
	mov	ecx, esi
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect

; 1294 : #endif
; 1295 : 		
; 1296 : 		DoVanish();

	mov	ecx, esi
	call	?DoVanish@KMissle@@AAEXXZ		; KMissle::DoVanish
	pop	edi
	pop	esi

; 1306 : 	}
; 1307 : }

	add	esp, 16					; 00000010H
	ret	0
$L101267:

; 1297 : 	}
; 1298 : 	else 
; 1299 : 	{
; 1300 : #ifndef _SERVER		
; 1301 : 		//	
; 1302 : 		if (m_MissleRes.SpecialMovieIsAllEnd())

	mov	eax, DWORD PTR [esi+476]
	cmp	DWORD PTR [eax+4], edi
	je	SHORT $L106389
	cmp	eax, edi
	jne	SHORT $L101271
$L106389:

; 1303 : 			CreateSpecialEffect(MS_DoCollision, nSrcX, nSrcY, m_nCurrentMapZ);

	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY$[esp+24]
	mov	eax, DWORD PTR _nSrcX$[esp+24]
	push	edi
	push	ecx
	push	edx
	push	eax
	push	3
	mov	ecx, esi
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
$L101271:

; 1304 : #endif
; 1305 : 		m_eMissleStatus = MS_DoFly;

	mov	DWORD PTR [esi+352], 1
$L101270:
	pop	edi
	pop	esi

; 1306 : 	}
; 1307 : }

	add	esp, 16					; 00000010H
	ret	0
?DoCollision@KMissle@@AAEXXZ ENDP			; KMissle::DoCollision
_TEXT	ENDS
;	COMDAT ?DoFly@KMissle@@AAEXXZ
_TEXT	SEGMENT
?DoFly@KMissle@@AAEXXZ PROC NEAR			; KMissle::DoFly, COMDAT

; 1311 : 	if (m_eMissleStatus == MS_DoFly) return ;

	mov	edx, DWORD PTR [ecx+352]
	mov	eax, 1
	cmp	edx, eax
	je	SHORT $L101274

; 1312 : 	//
; 1313 : 	m_eMissleStatus = MS_DoFly;

	mov	DWORD PTR [ecx+352], eax
$L101274:

; 1314 : }

	ret	0
?DoFly@KMissle@@AAEXXZ ENDP				; KMissle::DoFly
_TEXT	ENDS
;	COMDAT ?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z
_TEXT	SEGMENT
_nSubWorld$ = 8
_nSrcRegionId$ = 12
_nSrcMapX$ = 16
_nSrcMapY$ = 20
_nOffsetMapX$ = 24
_nOffsetMapY$ = 28
_nDesRegionId$ = 32
_nDesMapX$ = 36
_nDesMapY$ = 40
?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z PROC NEAR	; KMissle::GetOffsetAxis, COMDAT

; 1320 : 	nDesRegionId = -1;

	mov	eax, DWORD PTR _nDesRegionId$[esp-4]

; 1321 : 	// REGION
; 1322 : 	nDesMapX = nSrcMapX + nOffsetMapX;

	mov	ecx, DWORD PTR _nOffsetMapX$[esp-4]
	mov	edx, DWORD PTR _nSrcMapX$[esp-4]
	push	ebx

; 1323 : 	nDesMapY = nSrcMapY + nOffsetMapY;

	mov	ebx, DWORD PTR _nDesMapY$[esp]
	push	esi
	mov	esi, DWORD PTR _nDesMapX$[esp+4]
	mov	DWORD PTR [eax], -1
	mov	eax, DWORD PTR _nOffsetMapY$[esp+4]
	add	edx, ecx
	mov	ecx, DWORD PTR _nSrcMapY$[esp+4]
	mov	DWORD PTR [esi], edx
	add	ecx, eax
	push	edi
	mov	DWORD PTR [ebx], ecx

; 1324 : 	
; 1325 : 	if (nSrcRegionId < 0) 

	mov	ecx, DWORD PTR _nSrcRegionId$[esp+8]
	test	ecx, ecx
	jge	SHORT $L101287
	pop	edi
	pop	esi

; 1326 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 1357 : 	// REGIONNPCNPC		
; 1358 : 	//int nNpcIdx = SubWorld[nSubWorld].m_Region[nSearchRegion].FindNpc(nDesMapX, nDesMapY, nLauncherIdx, relation_all);
; 1359 : }

	ret	0
$L101287:

; 1327 : 
; 1328 : 	int nSearchRegion = nSrcRegionId;
; 1329 : 	if (nDesMapX < 0)

	mov	edx, DWORD PTR [esi]

; 1330 : 	{
; 1331 : 		nSearchRegion = SubWorld[nSubWorld].m_Region[nSearchRegion].m_nConnectRegion[2];

	mov	edi, DWORD PTR _nSubWorld$[esp+8]
	test	edx, edx
	mov	eax, edi
	jge	SHORT $L101289
	shl	eax, 6
	sub	eax, edi
	lea	edi, DWORD PTR [ecx+ecx*2]
	shl	eax, 2
	lea	ecx, DWORD PTR [ecx+edi*4]
	mov	edi, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+40]
	shl	ecx, 4
	mov	ecx, DWORD PTR [edi+ecx+112]

; 1332 : 		nDesMapX += SubWorld[nSubWorld].m_nRegionWidth;

	mov	edi, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+172]
	add	edi, edx
	mov	DWORD PTR [esi], edi

; 1333 : 	}
; 1334 : 	else if (nDesMapX >= SubWorld[nSubWorld].m_nRegionWidth)

	jmp	SHORT $L101291
$L101289:
	shl	eax, 6
	sub	eax, edi
	shl	eax, 2
	mov	edi, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+172]
	cmp	edx, edi
	jl	SHORT $L101291
	push	ebp

; 1335 : 	{
; 1336 : 		nSearchRegion = SubWorld[nSubWorld].m_Region[nSearchRegion].m_nConnectRegion[6];

	lea	ebp, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [ecx+ebp*4]
	mov	ebp, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+40]
	shl	ecx, 4

; 1337 : 		nDesMapX -= SubWorld[nSubWorld].m_nRegionWidth;

	sub	edx, edi
	mov	ecx, DWORD PTR [ecx+ebp+128]
	mov	DWORD PTR [esi], edx
	pop	ebp
$L101291:

; 1338 : 	}
; 1339 : 	if (nSearchRegion < 0) 

	test	ecx, ecx
	jge	SHORT $L101292
	pop	edi
	pop	esi

; 1340 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 1357 : 	// REGIONNPCNPC		
; 1358 : 	//int nNpcIdx = SubWorld[nSubWorld].m_Region[nSearchRegion].FindNpc(nDesMapX, nDesMapY, nLauncherIdx, relation_all);
; 1359 : }

	ret	0
$L101292:

; 1341 : 	
; 1342 : 	if (nDesMapY < 0)

	mov	edx, DWORD PTR [ebx]
	test	edx, edx
	jge	SHORT $L101293

; 1343 : 	{
; 1344 : 		nSearchRegion = SubWorld[nSubWorld].m_Region[nSearchRegion].m_nConnectRegion[4];

	lea	esi, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [ecx+esi*4]
	mov	esi, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+40]

; 1345 : 		nDesMapY += SubWorld[nSubWorld].m_nRegionHeight;

	mov	eax, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+176]
	shl	ecx, 4
	add	eax, edx
	mov	ecx, DWORD PTR [esi+ecx+120]
	mov	DWORD PTR [ebx], eax

; 1346 : 	}
; 1347 : 	else if (nDesMapY >= SubWorld[nSubWorld].m_nRegionHeight)

	jmp	SHORT $L101295
$L101293:
	mov	esi, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+176]
	cmp	edx, esi
	jl	SHORT $L101295

; 1348 : 	{
; 1349 : 		nSearchRegion = SubWorld[nSubWorld].m_Region[nSearchRegion].m_nConnectRegion[0];

	mov	eax, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[eax+40]
	lea	edi, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [ecx+edi*4]
	shl	ecx, 4

; 1350 : 		nDesMapY -= SubWorld[nSubWorld].m_nRegionHeight;

	sub	edx, esi
	mov	ecx, DWORD PTR [eax+ecx+104]
	mov	DWORD PTR [ebx], edx
$L101295:

; 1351 : 	}	
; 1352 : 
; 1353 : 	if (nSearchRegion < 0) 

	test	ecx, ecx
	jge	SHORT $L101296
	pop	edi
	pop	esi

; 1354 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 1357 : 	// REGIONNPCNPC		
; 1358 : 	//int nNpcIdx = SubWorld[nSubWorld].m_Region[nSearchRegion].FindNpc(nDesMapX, nDesMapY, nLauncherIdx, relation_all);
; 1359 : }

	ret	0
$L101296:

; 1355 : 	nDesRegionId = nSearchRegion;

	mov	edx, DWORD PTR _nDesRegionId$[esp+8]
	pop	edi
	pop	esi

; 1356 : 	return TRUE;

	mov	eax, 1
	mov	DWORD PTR [edx], ecx
	pop	ebx

; 1357 : 	// REGIONNPCNPC		
; 1358 : 	//int nNpcIdx = SubWorld[nSubWorld].m_Region[nSearchRegion].FindNpc(nDesMapX, nDesMapY, nLauncherIdx, relation_all);
; 1359 : }

	ret	0
?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z ENDP		; KMissle::GetOffsetAxis
_TEXT	ENDS
;	COMDAT ?ProcessCollision@KMissle@@AAEHHHHHHH@Z
_TEXT	SEGMENT
_nLauncherIdx$ = 8
_nRegionId$ = 12
_nMapX$ = 16
_nMapY$ = 20
_nRange$ = 24
_eRelation$ = 28
_nRangeX$ = -8
_nRet$ = -28
_nRMx$ = -12
_nRMy$ = -16
_nSearchRegion$ = -24
_i$ = -32
_j$101322 = -20
_nSrcX$101330 = 24
_nSrcY$101331 = 8
?ProcessCollision@KMissle@@AAEHHHHHHH@Z PROC NEAR	; KMissle::ProcessCollision, COMDAT

; 1375 : {

	sub	esp, 32					; 00000020H
	push	ebx
	push	ebp

; 1376 : #ifdef TOOLVERSION 
; 1377 : 	return 0;
; 1378 : #endif
; 1379 : #ifdef _SERVER
; 1380 : 	if (m_ulDamageInterval)
; 1381 : 	{
; 1382 : 		if (m_ulNextCalDamageTime > g_SubWorldSet.GetGameTime())
; 1383 : 		{
; 1384 : 			return FALSE;
; 1385 : 		}
; 1386 : 		else
; 1387 : 		{
; 1388 : 			m_ulNextCalDamageTime = g_SubWorldSet.GetGameTime() + m_ulDamageInterval;
; 1389 : 		}
; 1390 : 	}
; 1391 : #endif
; 1392 : 	if (nLauncherIdx <= 0 ) 

	mov	ebp, DWORD PTR _nLauncherIdx$[esp+36]
	mov	ebx, ecx
	test	ebp, ebp
	jg	SHORT $L101306
	pop	ebp

; 1393 : 		return 0;

	xor	eax, eax
	pop	ebx

; 1444 : }

	add	esp, 32					; 00000020H
	ret	24					; 00000018H
$L101306:

; 1394 : 	if (nRange <= 0) 

	mov	eax, DWORD PTR _nRange$[esp+36]
	test	eax, eax
	jg	SHORT $L101307
	pop	ebp

; 1395 : 		return 0;

	xor	eax, eax
	pop	ebx

; 1444 : }

	add	esp, 32					; 00000020H
	ret	24					; 00000018H
$L101307:

; 1396 : 	
; 1397 : 	int nRangeX = nRange / 2;

	cdq
	sub	eax, edx
	push	edi
	mov	ecx, eax

; 1398 : 	int	nRangeY = nRangeX;
; 1399 : 	int	nSubWorld = Npc[nLauncherIdx].m_SubWorldIndex;

	lea	eax, DWORD PTR [ebp+ebp*2]
	shl	eax, 3
	sub	eax, ebp

; 1400 : 	
; 1401 : 	_ASSERT(Npc[nLauncherIdx].m_SubWorldIndex >= 0);
; 1402 : 	_ASSERT(nRegionId >= 0);
; 1403 : 	
; 1404 : 	int	nRegion = nRegionId;
; 1405 : 	int	nRet = 0;

	mov	DWORD PTR _nRet$[esp+44], 0
	sar	ecx, 1
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _nRangeX$[esp+44], ecx
	shl	eax, 4
	add	eax, ebp
	lea	eax, DWORD PTR [eax+eax*8]
	mov	edi, DWORD PTR ?Npc@@3PAVKNpc@@A[eax*4+2604]

; 1406 : 	int	nRMx, nRMy, nSearchRegion;
; 1407 : 
; 1408 : 	for (int i = -nRangeX; i <= nRangeX; i++)

	mov	eax, ecx
	neg	eax
	mov	edx, eax
	mov	DWORD PTR -4+[esp+44], eax
	cmp	edx, ecx
	mov	DWORD PTR _i$[esp+44], edx
	jg	$L101321
	push	esi
$L101319:

; 1409 : 	{
; 1410 : 		for (int j = -nRangeY; j <= nRangeY; j++)

	cmp	eax, ecx
	mov	DWORD PTR _j$101322[esp+48], eax
	jg	$L101320
	jmp	SHORT $L101323
$L106413:
	mov	edx, DWORD PTR _i$[esp+48]
$L101323:

; 1411 : 		{
; 1412 : 			if (!GetOffsetAxis(nSubWorld, nRegionId, nMapX, nMapY, i , j , nSearchRegion, nRMx, nRMy))

	lea	ecx, DWORD PTR _nRMy$[esp+48]
	push	ecx
	lea	ecx, DWORD PTR _nRMx$[esp+52]
	push	ecx
	lea	ecx, DWORD PTR _nSearchRegion$[esp+56]
	push	ecx
	mov	ecx, DWORD PTR _nRegionId$[esp+56]
	push	eax
	mov	eax, DWORD PTR _nMapX$[esp+60]
	push	edx
	mov	edx, DWORD PTR _nMapY$[esp+64]
	push	edx
	push	eax
	push	ecx
	push	edi
	call	?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z ; KMissle::GetOffsetAxis
	add	esp, 36					; 00000024H
	test	eax, eax
	je	$L101324

; 1413 : 				continue;
; 1414 : 
; 1415 : 			_ASSERT(nSearchRegion >= 0);
; 1416 : 		
; 1417 : 			int nNpcIdx = SubWorld[nSubWorld].m_Region[nSearchRegion].FindNpc(nRMx, nRMy, nLauncherIdx, eRelation);

	mov	edx, DWORD PTR _eRelation$[esp+44]
	mov	eax, DWORD PTR _nRMy$[esp+48]
	mov	ecx, DWORD PTR _nRMx$[esp+48]
	push	edx
	push	ebp
	push	eax
	mov	eax, DWORD PTR _nSearchRegion$[esp+60]
	mov	edx, edi
	push	ecx
	shl	edx, 6
	lea	ecx, DWORD PTR [eax+eax*2]
	sub	edx, edi
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+40]
	shl	eax, 4
	add	ecx, eax
	call	?FindNpc@KRegion@@QAEHHHHH@Z		; KRegion::FindNpc
	mov	esi, eax

; 1418 : 			if (nNpcIdx > 0)	

	test	esi, esi
	jle	$L101324

; 1419 : 			{	
; 1420 : 
; 1421 : 				nRet++;
; 1422 : #ifndef _SERVER
; 1423 : 				int nSrcX = 0;

	xor	eax, eax
	mov	edx, DWORD PTR _nRet$[esp+48]
	mov	DWORD PTR _nSrcX$101330[esp+44], eax

; 1424 : 				int nSrcY = 0;

	mov	DWORD PTR _nSrcY$101331[esp+44], eax

; 1425 : 				SubWorld[0].Map2Mps(nSearchRegion, Npc[nNpcIdx].m_MapX,Npc[nNpcIdx].m_MapY, Npc[nNpcIdx].m_OffX, Npc[nNpcIdx].m_OffY,  &nSrcX, &nSrcY);

	lea	eax, DWORD PTR [esi+esi*2]
	inc	edx
	shl	eax, 3
	sub	eax, esi
	mov	DWORD PTR _nRet$[esp+48], edx
	lea	ecx, DWORD PTR _nSrcY$101331[esp+44]
	lea	edx, DWORD PTR _nSrcX$101330[esp+44]
	lea	eax, DWORD PTR [eax+eax*2]
	push	ecx
	shl	eax, 4
	add	eax, esi
	push	edx
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3128]
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3124]
	push	ecx
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3116]
	push	edx
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3112]
	mov	eax, DWORD PTR _nSearchRegion$[esp+64]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET FLAT:?SubWorld@@3PAVKSubWorld@@A
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 1426 : 				
; 1427 : 				if (m_bFollowNpcWhenCollid)

	mov	eax, DWORD PTR [ebx+452]
	test	eax, eax
	je	SHORT $L101332

; 1428 : 					CreateSpecialEffect(MS_DoCollision, nSrcX, nSrcY, m_nCurrentMapZ, nNpcIdx);

	push	esi

; 1429 : 				else 

	jmp	SHORT $L106415
$L101332:

; 1430 : 					CreateSpecialEffect(MS_DoCollision, nSrcX, nSrcY, m_nCurrentMapZ);

	push	0
$L106415:
	mov	ecx, DWORD PTR [ebx+224]
	mov	edx, DWORD PTR _nSrcY$101331[esp+48]
	mov	eax, DWORD PTR _nSrcX$101330[esp+48]
	push	ecx
	push	edx
	push	eax
	push	3
	mov	ecx, ebx
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
$L101324:
	mov	eax, DWORD PTR _j$101322[esp+48]
	mov	ecx, DWORD PTR _nRangeX$[esp+48]
	inc	eax
	cmp	eax, ecx
	mov	DWORD PTR _j$101322[esp+48], eax
	jle	$L106413
	mov	eax, DWORD PTR -4+[esp+48]
	mov	edx, DWORD PTR _i$[esp+48]
$L101320:
	inc	edx
	cmp	edx, ecx
	mov	DWORD PTR _i$[esp+48], edx
	jle	$L101319
	pop	esi
$L101321:

; 1431 : #else
; 1432 : 				ProcessDamage(nNpcIdx);	
; 1433 : 				
; 1434 : 				if(m_btHitCount > 0)
; 1435 : 				{	
; 1436 : 					if(nRet >= m_btHitCount) 
; 1437 : 						break;
; 1438 : 				}
; 1439 : #endif
; 1440 : 			}
; 1441 : 		}
; 1442 : 	}
; 1443 : 	return nRet;

	mov	eax, DWORD PTR _nRet$[esp+44]
	pop	edi
	pop	ebp
	pop	ebx

; 1444 : }

	add	esp, 32					; 00000020H
	ret	24					; 00000018H
?ProcessCollision@KMissle@@AAEHHHHHHH@Z ENDP		; KMissle::ProcessCollision
_TEXT	ENDS
;	COMDAT ?ProcessCollision@KMissle@@AAEHXZ
_TEXT	SEGMENT
?ProcessCollision@KMissle@@AAEHXZ PROC NEAR		; KMissle::ProcessCollision, COMDAT

; 1449 : #ifdef TOOLVERSION
; 1450 : 	return 0;
; 1451 : #endif
; 1452 : 	if (m_bClientSend) return 0;

	mov	eax, DWORD PTR [ecx+64]
	test	eax, eax
	je	SHORT $L101337
	xor	eax, eax

; 1454 : }

	ret	0
$L101337:

; 1453 : 	return ProcessCollision(m_nLauncher, m_nRegionId, m_nCurrentMapX, m_nCurrentMapY, m_nDamageRange , m_eRelation);

	mov	eax, DWORD PTR [ecx+108]
	mov	edx, DWORD PTR [ecx+148]
	push	eax
	mov	eax, DWORD PTR [ecx+220]
	push	edx
	mov	edx, DWORD PTR [ecx+216]
	push	eax
	mov	eax, DWORD PTR [ecx+364]
	push	edx
	mov	edx, DWORD PTR [ecx+332]
	push	eax
	push	edx
	call	?ProcessCollision@KMissle@@AAEHHHHHHH@Z	; KMissle::ProcessCollision

; 1454 : }

	ret	0
?ProcessCollision@KMissle@@AAEHXZ ENDP			; KMissle::ProcessCollision
_TEXT	ENDS
PUBLIC	??_7KSkillSpecialNode@@6B@			; KSkillSpecialNode::`vftable'
PUBLIC	??_GKSkillSpecialNode@@UAEPAXI@Z		; KSkillSpecialNode::`scalar deleting destructor'
PUBLIC	??_EKSkillSpecialNode@@UAEPAXI@Z		; KSkillSpecialNode::`vector deleting destructor'
EXTRN	?g_SubWorldSet@@3VKSubWorldSet@@A:BYTE		; g_SubWorldSet
EXTRN	??0KSkillSpecial@@QAE@XZ:NEAR			; KSkillSpecial::KSkillSpecial
EXTRN	?Init@KSkillSpecial@@QAEHXZ:NEAR		; KSkillSpecial::Init
;	COMDAT ??_7KSkillSpecialNode@@6B@
; File ..\engine\src\KNode.h
CONST	SEGMENT
??_7KSkillSpecialNode@@6B@ DD FLAT:??_EKSkillSpecialNode@@UAEPAXI@Z ; KSkillSpecialNode::`vftable'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
$T106484 DD	019930520H
	DD	01H
	DD	FLAT:$T106489
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	ORG $+4
$T106489 DD	0ffffffffH
	DD	FLAT:$L106431
xdata$x	ENDS
;	COMDAT ?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z
_TEXT	SEGMENT
$T106427 = 24
_eStatus$ = 8
_nPX$ = 12
_nPY$ = 16
_nPZ$ = 20
_nNpcIndex$ = 24
_this$ = -16
__$EHRec$ = -12
?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z PROC NEAR ; KMissle::CreateSpecialEffect, COMDAT

; 1460 : {

	push	-1
	push	$L106488
	mov	eax, DWORD PTR fs:__except_list
	push	eax
	mov	DWORD PTR fs:__except_list, esp
	push	ecx
	push	ebx
	push	ebp
	push	esi

; 1461 : 	
; 1462 : 	KSkillSpecialNode * pNode = NULL;
; 1463 : 	//Npc
; 1464 : 	if (nNpcIndex > 0)

	mov	esi, DWORD PTR _nNpcIndex$[esp+24]
	xor	ebp, ebp
	mov	ebx, ecx
	cmp	esi, ebp
	push	edi
	mov	DWORD PTR _this$[esp+32], ebx
	jle	SHORT $L101352

; 1465 : 	{
; 1466 : 		pNode = (KSkillSpecialNode*)m_MissleRes.m_SkillSpecialList.GetHead();

	mov	ecx, DWORD PTR [ebx+476]
	mov	eax, DWORD PTR [ecx+4]
	neg	eax
	sbb	eax, eax
	and	eax, ecx

; 1467 : 		while(pNode)

	cmp	eax, ebp
	je	SHORT $L101352

; 1468 : 		{
; 1469 : 			if (pNode->m_pSkillSpecial->m_dwMatchID == Npc[nNpcIndex].m_dwID) return FALSE;

	lea	ecx, DWORD PTR [esi+esi*2]
	shl	ecx, 3
	sub	ecx, esi
	lea	ecx, DWORD PTR [ecx+ecx*2]
	shl	ecx, 4
	add	ecx, esi
	lea	ecx, DWORD PTR [ecx+ecx*8]
	mov	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[ecx*4]
$L101351:
	mov	edx, DWORD PTR [eax+12]
	cmp	DWORD PTR [edx+44], ecx
	je	SHORT $L106486

; 1470 : 			pNode = (KSkillSpecialNode*)pNode->GetNext();

	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+4], ebp
	je	SHORT $L101352

; 1467 : 		while(pNode)

	cmp	eax, ebp
	jne	SHORT $L101351
$L101352:

; 1471 : 		}
; 1472 : 	}
; 1473 : 	m_MissleRes.PlaySound(eStatus, nPX, nPY, 0);

	mov	eax, DWORD PTR _nPY$[esp+28]
	mov	ecx, DWORD PTR _nPX$[esp+28]
	mov	edi, DWORD PTR _eStatus$[esp+28]
	push	ebp
	push	eax
	push	ecx
	push	edi
	lea	ecx, DWORD PTR [ebx+472]
	call	?PlaySoundA@KMissleRes@@QAEXHHHH@Z	; KMissleRes::PlaySoundA

; 1474 : 	if (!m_MissleRes.m_MissleRes[eStatus].AnimFileName[0]) return FALSE; 

	lea	edx, DWORD PTR [edi+edi*2]
	lea	eax, DWORD PTR [edi+edx*4]
	lea	ecx, DWORD PTR [edi+eax*4]
	lea	ebx, DWORD PTR [ebx+ecx*4]
	mov	al, BYTE PTR [ebx+504]
	lea	edi, DWORD PTR [ebx+504]
	test	al, al
	jne	SHORT $L101355
$L106486:
	xor	eax, eax
	jmp	$L101346
$L101355:

; 1475 : 	pNode = new KSkillSpecialNode;

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	cmp	eax, ebp
	je	SHORT $L106425
	mov	DWORD PTR [eax+4], ebp
	mov	DWORD PTR [eax+8], ebp
	mov	DWORD PTR [eax+12], ebp
	mov	DWORD PTR [eax], OFFSET FLAT:??_7KSkillSpecialNode@@6B@ ; KSkillSpecialNode::`vftable'
	mov	ebp, eax
$L106425:

; 1476 : 	KSkillSpecial * pSkillSpecial = new KSkillSpecial;

	push	240					; 000000f0H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T106427[esp+28], eax
	xor	ecx, ecx
	cmp	eax, ecx
	mov	DWORD PTR __$EHRec$[esp+40], ecx
	je	SHORT $L106429
	mov	ecx, eax
	call	??0KSkillSpecial@@QAE@XZ		; KSkillSpecial::KSkillSpecial
	mov	ecx, eax
$L106429:

; 1477 : 	pNode->m_pSkillSpecial = pSkillSpecial;
; 1478 : 	
; 1479 : 	int nSrcX = nPX;
; 1480 : 	int nSrcY = nPY;
; 1481 : 	
; 1482 : 	pSkillSpecial->m_nPX = nSrcX;
; 1483 : 	pSkillSpecial->m_nPY = nSrcY - 5;

	mov	eax, DWORD PTR _nPY$[esp+28]
	mov	DWORD PTR [ebp+12], ecx
	add	eax, -5					; fffffffbH
	mov	edx, DWORD PTR _nPX$[esp+28]
	mov	DWORD PTR [ecx+28], eax

; 1484 : 	pSkillSpecial->m_nPZ = nPZ;
; 1485 : 	pSkillSpecial->m_nNpcIndex = nNpcIndex;
; 1486 : 	pSkillSpecial->m_dwMatchID = Npc[nNpcIndex].m_dwID;

	lea	eax, DWORD PTR [esi+esi*2]
	shl	eax, 3
	sub	eax, esi
	mov	DWORD PTR [ecx+24], edx
	mov	edx, DWORD PTR _nPZ$[esp+28]
	mov	DWORD PTR [ecx+40], esi
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [ecx+32], edx
	shl	eax, 4
	add	eax, esi
	mov	DWORD PTR __$EHRec$[esp+40], -1
	lea	eax, DWORD PTR [eax+eax*8]
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax*4]

; 1487 : 	pSkillSpecial->m_pMissleRes = &m_MissleRes.m_MissleRes[eStatus];

	mov	DWORD PTR [ecx+48], edi
	mov	DWORD PTR [ecx+44], edx

; 1488 : 	pSkillSpecial->m_nBeginTime = g_SubWorldSet.GetGameTime();

	mov	eax, DWORD PTR ?g_SubWorldSet@@3VKSubWorldSet@@A
	mov	DWORD PTR [ecx+52], eax

; 1489 : 	pSkillSpecial->m_nEndTime = g_SubWorldSet.GetGameTime() + (pSkillSpecial->m_pMissleRes->nInterval * pSkillSpecial->m_pMissleRes->nTotalFrame / pSkillSpecial->m_pMissleRes->nDir);

	mov	eax, DWORD PTR [edi+104]
	imul	eax, DWORD PTR [edi+100]
	cdq
	idiv	DWORD PTR [edi+108]
	add	eax, DWORD PTR ?g_SubWorldSet@@3VKSubWorldSet@@A
	mov	DWORD PTR [ecx+56], eax

; 1490 : 	pSkillSpecial->m_nCurDir = g_DirIndex2Dir(m_nDirIndex, m_MissleRes.m_MissleRes[eStatus].nDir);

	mov	eax, DWORD PTR [ebx+612]
	test	eax, eax
	jg	SHORT $L106466
	or	edx, -1
	jmp	SHORT $L106464
$L106466:
	mov	edx, DWORD PTR _this$[esp+32]
	mov	edx, DWORD PTR [edx+420]
	imul	edx, eax
	sar	edx, 6
$L106464:
	mov	DWORD PTR [ecx+36], edx

; 1491 : 	pSkillSpecial->Init();

	call	?Init@KSkillSpecial@@QAEHXZ		; KSkillSpecial::Init

; 1492 : 	m_MissleRes.m_SkillSpecialList.AddTail(pNode);

	mov	eax, DWORD PTR _this$[esp+32]
	add	eax, 484				; 000001e4H
	test	ebp, ebp
	je	SHORT $L106481
	mov	ecx, DWORD PTR [eax+8]
	test	ecx, ecx
	je	SHORT $L106481
	mov	DWORD PTR [ebp+8], ecx
	mov	DWORD PTR [ebp+4], eax
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+4], ebp
	mov	DWORD PTR [eax+8], ebp
$L106481:

; 1493 : 	
; 1494 : 	return TRUE;

	mov	eax, 1
$L101346:

; 1495 : }

	mov	ecx, DWORD PTR __$EHRec$[esp+32]
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	mov	DWORD PTR fs:__except_list, ecx
	add	esp, 16					; 00000010H
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$L106431:
	mov	eax, DWORD PTR $T106427[ebp-4]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	pop	ecx
	ret	0
$L106488:
	mov	eax, OFFSET FLAT:$T106484
	jmp	___CxxFrameHandler
text$x	ENDS
?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ENDP ; KMissle::CreateSpecialEffect
PUBLIC	??1KSkillSpecialNode@@UAE@XZ			; KSkillSpecialNode::~KSkillSpecialNode
;	COMDAT ??_GKSkillSpecialNode@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8
??_GKSkillSpecialNode@@UAEPAXI@Z PROC NEAR		; KSkillSpecialNode::`scalar deleting destructor', COMDAT
	push	esi
	mov	esi, ecx
	call	??1KSkillSpecialNode@@UAE@XZ		; KSkillSpecialNode::~KSkillSpecialNode
	test	BYTE PTR ___flags$[esp], 1
	je	SHORT $L106495
	push	esi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$L106495:
	mov	eax, esi
	pop	esi
	ret	4
??_GKSkillSpecialNode@@UAEPAXI@Z ENDP			; KSkillSpecialNode::`scalar deleting destructor'
_TEXT	ENDS
;	COMDAT ??1KSkillSpecialNode@@UAE@XZ
_TEXT	SEGMENT
??1KSkillSpecialNode@@UAE@XZ PROC NEAR			; KSkillSpecialNode::~KSkillSpecialNode, COMDAT

; 57   : 	~KSkillSpecialNode(){delete m_pSkillSpecial;};

	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [esi], OFFSET FLAT:??_7KSkillSpecialNode@@6B@ ; KSkillSpecialNode::`vftable'
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
	mov	DWORD PTR [esi], OFFSET FLAT:??_7KNode@@6B@ ; KNode::`vftable'
	pop	esi
	ret	0
??1KSkillSpecialNode@@UAE@XZ ENDP			; KSkillSpecialNode::~KSkillSpecialNode
_TEXT	ENDS
PUBLIC	?CreateMissleForShow@KMissle@@SAHPAD00PAUTMissleForShow@@@Z ; KMissle::CreateMissleForShow
EXTRN	?Player@@3PAVKPlayer@@A:BYTE			; Player
EXTRN	?Add@KMissleSet@@QAEHHHH@Z:NEAR			; KMissleSet::Add
EXTRN	?MissleSet@@3VKMissleSet@@A:BYTE		; MissleSet
EXTRN	?LoadResource@KMissleRes@@QAEXHPAD0@Z:NEAR	; KMissleRes::LoadResource
;	COMDAT ?CreateMissleForShow@KMissle@@SAHPAD00PAUTMissleForShow@@@Z
_TEXT	SEGMENT
_nPY$ = -8
_pcszTemp$ = 20
_szMovie$ = 8
_szFormat$ = 12
_szSound$ = 16
_pShowParam$ = 20
_nPX$ = -4
?CreateMissleForShow@KMissle@@SAHPAD00PAUTMissleForShow@@@Z PROC NEAR ; KMissle::CreateMissleForShow, COMDAT

; 1498 : {

	sub	esp, 8
	push	ebx
	push	ebp

; 1499 : 	if (!pShowParam || !szMovie || !szMovie[0])

	mov	ebp, DWORD PTR _pShowParam$[esp+12]
	xor	ebx, ebx
	cmp	ebp, ebx
	push	edi
	je	$L101374
	mov	eax, DWORD PTR _szMovie$[esp+16]
	cmp	eax, ebx
	je	$L101374
	cmp	BYTE PTR [eax], bl
	je	$L101374

; 1501 : 	int nPX = 0;
; 1502 : 	int nPY = 0;
; 1503 : 	int nPZ = 0;
; 1504 : 	
; 1505 : 	if (pShowParam->nNpcIndex > 0)

	mov	ecx, DWORD PTR [ebp+12]
	mov	DWORD PTR _nPX$[esp+20], ebx
	cmp	ecx, ebx
	mov	DWORD PTR _nPY$[esp+20], ebx
	jle	SHORT $L101378

; 1506 : 	{
; 1507 : 		Npc[pShowParam->nNpcIndex].GetMpsPos(&nPX, &nPY);

	lea	eax, DWORD PTR _nPY$[esp+20]
	lea	edx, DWORD PTR _nPX$[esp+20]
	push	eax
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	push	edx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	lea	eax, DWORD PTR [eax+eax*8]
	lea	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax*4]
	call	?GetMpsPos@KNpc@@QAEXPAH0@Z		; KNpc::GetMpsPos

; 1508 : 	}
; 1509 : 	else

	jmp	SHORT $L101379
$L101378:

; 1510 : 	{
; 1511 : 		nPX = pShowParam->nPX;

	mov	ecx, DWORD PTR [ebp]

; 1512 : 		nPY = pShowParam->nPY;

	mov	edx, DWORD PTR [ebp+4]
	mov	DWORD PTR _nPX$[esp+20], ecx
	mov	DWORD PTR _nPY$[esp+20], edx
$L101379:

; 1513 : 	}
; 1514 : 
; 1515 : 	int nSubWorldId = Npc[Player[CLIENT_PLAYER_INDEX].m_nIndex].m_SubWorldIndex;

	mov	ecx, DWORD PTR ?Player@@3PAVKPlayer@@A+52924

; 1516 : 	int nMissleIndex = MissleSet.Add(nSubWorldId , nPX , nPY);

	mov	edx, DWORD PTR _nPX$[esp+20]
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	mov	ecx, DWORD PTR _nPY$[esp+20]
	push	ecx
	push	edx
	lea	eax, DWORD PTR [eax+eax*8]
	mov	ecx, OFFSET FLAT:?MissleSet@@3VKMissleSet@@A
	mov	edi, DWORD PTR ?Npc@@3PAVKNpc@@A[eax*4+2604]
	push	edi
	call	?Add@KMissleSet@@QAEHHHH@Z		; KMissleSet::Add

; 1517 : 	if (nMissleIndex < 0)	

	cmp	eax, ebx

; 1518 : 		return FALSE;

	jl	$L101374

; 1519 : 	
; 1520 : 	Missle[nMissleIndex].m_nDir				= Npc[Player[CLIENT_PLAYER_INDEX].m_nIndex].m_Dir;

	mov	ecx, DWORD PTR ?Player@@3PAVKPlayer@@A+52924
	push	esi
	lea	esi, DWORD PTR [eax+eax*2]
	shl	esi, 3
	sub	esi, eax
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	shl	esi, 7
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx

; 1521 : 	Missle[nMissleIndex].m_nDirIndex		= g_Dir2DirIndex(Missle[nMissleIndex].m_nDir, MaxMissleDir);
; 1522 : 	Missle[nMissleIndex].m_nFollowNpcIdx	= 0;
; 1523 : 	Missle[nMissleIndex].m_dwBornTime		= SubWorld[nSubWorldId].m_dwCurrentTime;

	mov	ecx, edi
	shl	ecx, 6
	lea	eax, DWORD PTR [eax+eax*8]
	sub	ecx, edi
	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[eax*4+3096]
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+424], eax
	shl	eax, 6
	cdq
	and	edx, 63					; 0000003fH
	add	eax, edx
	mov	edx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4+200]
	sar	eax, 6
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+420], eax
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+324], ebx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+432], edx

; 1524 : 	Missle[nMissleIndex].m_nSubWorldId		= nSubWorldId;

	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+360], edi

; 1525 : 	Missle[nMissleIndex].m_nLauncher		= pShowParam->nLauncherIndex;

	mov	eax, DWORD PTR [ebp+16]

; 1526 : 	Missle[nMissleIndex].m_dwLauncherId		= Npc[pShowParam->nLauncherIndex].m_dwID;
; 1527 : 	
; 1528 : 	Missle[nMissleIndex].m_nParentMissleIndex = 0;
; 1529 : 	
; 1530 : 	Missle[nMissleIndex].m_nSkillId			= 0;
; 1531 : 	Missle[nMissleIndex].m_nStartLifeTime	= 0;
; 1532 : 	Missle[nMissleIndex].m_nLifeTime		= 1;
; 1533 : 	Missle[nMissleIndex].m_nRefPX			= 0;
; 1534 : 	Missle[nMissleIndex].m_nRefPY			= 0;
; 1535 : 	Missle[nMissleIndex].m_MissleRes.Clear();

	lea	edi, DWORD PTR ?Missle@@3PAVKMissle@@A[esi+472]
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+332], eax
	mov	ecx, DWORD PTR [ebp+16]
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	lea	ecx, DWORD PTR [eax+eax*8]
	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[ecx*4]
	mov	ecx, edi
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+336], edx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+340], ebx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+100], ebx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+208], ebx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+92], 1
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+236], ebx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+240], ebx
	call	?Clear@KMissleRes@@QAEXXZ		; KMissleRes::Clear

; 1536 : 
; 1537 : 	Missle[nMissleIndex].m_MissleRes.LoadResource(MS_DoWait, szMovie, szSound);

	mov	eax, DWORD PTR _szSound$[esp+20]
	mov	ecx, DWORD PTR _szMovie$[esp+20]
	push	eax
	push	ecx
	push	ebx
	mov	ecx, edi
	call	?LoadResource@KMissleRes@@QAEXHPAD0@Z	; KMissleRes::LoadResource

; 1538 : 	char * pcszTemp = szFormat;

	mov	edx, DWORD PTR _szFormat$[esp+20]

; 1539 : 	Missle[nMissleIndex].m_MissleRes.m_MissleRes[MS_DoWait].nTotalFrame = KSG_StringGetInt(&pcszTemp, 100);

	mov	edi, DWORD PTR __imp_?KSG_StringGetInt@@YAHPAPBDH@Z
	lea	eax, DWORD PTR _pcszTemp$[esp+20]
	push	100					; 00000064H
	push	eax
	mov	DWORD PTR _pcszTemp$[esp+28], edx
	call	edi

; 1540 : 	KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	ecx, DWORD PTR _pcszTemp$[esp+28]
	push	44					; 0000002cH
	push	ecx
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+604], eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 1541 : 	Missle[nMissleIndex].m_MissleRes.m_MissleRes[MS_DoWait].nDir = KSG_StringGetInt(&pcszTemp, 16);

	lea	edx, DWORD PTR _pcszTemp$[esp+36]
	push	16					; 00000010H
	push	edx
	call	edi
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+612], eax

; 1542 : 	KSG_StringSkipSymbol(&pcszTemp, ',');

	lea	eax, DWORD PTR _pcszTemp$[esp+44]
	push	44					; 0000002cH
	push	eax
	call	DWORD PTR __imp_?KSG_StringSkipSymbol@@YA_NPAPBDH@Z

; 1543 :     Missle[nMissleIndex].m_MissleRes.m_MissleRes[MS_DoWait].nInterval = KSG_StringGetInt(&pcszTemp, 1);

	lea	ecx, DWORD PTR _pcszTemp$[esp+52]
	push	1
	push	ecx
	call	edi

; 1544 : 
; 1545 : 	Missle[nMissleIndex].CreateSpecialEffect(MS_DoWait, nPX, nPY, nPZ, pShowParam->nNpcIndex);

	mov	ecx, DWORD PTR _nPX$[esp+64]
	add	esp, 40					; 00000028H
	mov	DWORD PTR ?Missle@@3PAVKMissle@@A[esi+608], eax
	mov	edx, DWORD PTR [ebp+12]
	mov	eax, DWORD PTR _nPY$[esp+24]
	push	edx
	push	ebx
	push	eax
	push	ecx
	push	ebx
	lea	ecx, DWORD PTR ?Missle@@3PAVKMissle@@A[esi]
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
	pop	esi
	pop	edi
	pop	ebp

; 1546 : 	return TRUE;

	mov	eax, 1
	pop	ebx

; 1547 : }

	add	esp, 8
	ret	0
$L101374:
	pop	edi
	pop	ebp

; 1500 : 		return FALSE;

	xor	eax, eax
	pop	ebx

; 1547 : }

	add	esp, 8
	ret	0
?CreateMissleForShow@KMissle@@SAHPAD00PAUTMissleForShow@@@Z ENDP ; KMissle::CreateMissleForShow
_TEXT	ENDS
PUBLIC	?GetMpsPos@KMissle@@QAEXPAH0@Z			; KMissle::GetMpsPos
PUBLIC	?GetLightInfo@KMissle@@QAEXPAUKLightInfo@@@Z	; KMissle::GetLightInfo
;	COMDAT ?GetLightInfo@KMissle@@QAEXPAUKLightInfo@@@Z
_TEXT	SEGMENT
_pLightInfo$ = 8
_nPX$ = 8
_nPY$ = -4
?GetLightInfo@KMissle@@QAEXPAUKLightInfo@@@Z PROC NEAR	; KMissle::GetLightInfo, COMDAT

; 1550 : {

	push	ecx
	push	esi
	push	edi

; 1551 : 	if (!pLightInfo) 

	mov	edi, DWORD PTR _pLightInfo$[esp+8]
	mov	esi, ecx
	test	edi, edi
	je	SHORT $L101387

; 1552 : 	{
; 1553 : 		return ;
; 1554 : 	}
; 1555 : 	
; 1556 : 	int nPX, nPY, nPZ;
; 1557 : 	GetMpsPos(&nPX, &nPY);

	lea	eax, DWORD PTR _nPY$[esp+12]
	lea	ecx, DWORD PTR _nPX$[esp+8]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?GetMpsPos@KMissle@@QAEXPAH0@Z		; KMissle::GetMpsPos

; 1558 : 	nPZ = m_nCurrentMapZ;

	mov	eax, DWORD PTR [esi+224]

; 1559 : 	
; 1560 : 	pLightInfo->oPosition.nX = nPX;

	mov	edx, DWORD PTR _nPX$[esp+8]

; 1561 : 	pLightInfo->oPosition.nY = nPY;

	mov	ecx, DWORD PTR _nPY$[esp+12]
	mov	DWORD PTR [edi], edx
	mov	DWORD PTR [edi+4], ecx

; 1562 : 	pLightInfo->oPosition.nZ = nPZ;

	mov	DWORD PTR [edi+8], eax

; 1563 : 	pLightInfo->dwColor = 0xff000000 | m_btRedLum << 16 | m_btGreenLum << 8 | m_btBlueLum;

	mov	edx, DWORD PTR [esi+456]
	mov	eax, DWORD PTR [esi+460]
	or	edx, -256				; ffffff00H
	shl	edx, 8
	or	edx, eax
	mov	eax, DWORD PTR [esi+464]
	shl	edx, 8
	or	edx, eax

; 1564 : 	pLightInfo->nRadius = m_usLightRadius;

	xor	eax, eax
	mov	DWORD PTR [edi+12], edx
	mov	ax, WORD PTR [esi+468]
	mov	DWORD PTR [edi+16], eax
$L101387:
	pop	edi
	pop	esi

; 1565 : }

	pop	ecx
	ret	4
?GetLightInfo@KMissle@@QAEXPAUKLightInfo@@@Z ENDP	; KMissle::GetLightInfo
_TEXT	ENDS
PUBLIC	?DoWait@KMissle@@AAEXXZ				; KMissle::DoWait
;	COMDAT ?DoWait@KMissle@@AAEXXZ
_TEXT	SEGMENT
_nSrcX$ = -4
_nSrcY$ = -8
?DoWait@KMissle@@AAEXXZ PROC NEAR			; KMissle::DoWait, COMDAT

; 1569 : {

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 1570 : 	m_eMissleStatus = MS_DoWait;
; 1571 : 	
; 1572 : #ifndef _SERVER 
; 1573 : 	int nSrcX = 0 ;
; 1574 : 	int nSrcY = 0 ;
; 1575 : 	SubWorld[0].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY,m_nXOffset, m_nYOffset, &nSrcX, &nSrcY);

	lea	eax, DWORD PTR _nSrcY$[esp+12]
	lea	ecx, DWORD PTR _nSrcX$[esp+12]
	mov	edx, DWORD PTR [esi+232]
	push	eax
	mov	eax, DWORD PTR [esi+228]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	push	edx
	push	eax
	mov	ecx, OFFSET FLAT:?SubWorld@@3PAVKSubWorld@@A
	mov	DWORD PTR [esi+352], 0
	mov	DWORD PTR _nSrcX$[esp+40], 0
	mov	DWORD PTR _nSrcY$[esp+40], 0
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 1576 : 	CreateSpecialEffect(MS_DoWait, nSrcX, nSrcY, m_nCurrentMapZ);

	mov	ecx, DWORD PTR [esi+224]
	mov	edx, DWORD PTR _nSrcY$[esp+12]
	mov	eax, DWORD PTR _nSrcX$[esp+12]
	push	0
	push	ecx
	push	edx
	push	eax
	push	0
	mov	ecx, esi
	call	?CreateSpecialEffect@KMissle@@QAEHW4eMissleStatus@@HHHH@Z ; KMissle::CreateSpecialEffect
	pop	esi

; 1577 : #endif
; 1578 : 	
; 1579 : }

	add	esp, 8
	ret	0
?DoWait@KMissle@@AAEXXZ ENDP				; KMissle::DoWait
_TEXT	ENDS
;	COMDAT ?PrePareFly@KMissle@@AAEHXZ
_TEXT	SEGMENT
_nPX$101402 = -16
_nPY$101403 = -12
_nParentPX$101412 = -16
_nParentPY$101413 = -4
_nSrcPX$101414 = -12
_nSrcPY$101415 = -8
_nParentPX$101418 = -8
_nParentPY$101419 = -16
_nSrcPX$101420 = -4
_nSrcPY$101421 = -12
_nOldRegion$101422 = -4
?PrePareFly@KMissle@@AAEHXZ PROC NEAR			; KMissle::PrePareFly, COMDAT

; 1582 : {

	sub	esp, 16					; 00000010H
	push	ebx
	push	ebp
	push	esi
	mov	esi, ecx
	push	edi

; 1583 : 	if (m_eMoveKind == MISSLE_MMK_RollBack)

	cmp	DWORD PTR [esi+76], 100			; 00000064H
	jne	SHORT $L101400

; 1584 : 		m_nTempParam2 =  m_nStartLifeTime + (m_nLifeTime - m_nStartLifeTime ) / 2;

	mov	ecx, DWORD PTR [esi+208]
	mov	eax, DWORD PTR [esi+92]
	sub	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	add	eax, ecx
	mov	DWORD PTR [esi+416], eax
$L101400:

; 1585 : 
; 1586 : 	if (m_nInteruptTypeWhenMove)

	mov	eax, DWORD PTR [esi+128]
	test	eax, eax
	je	SHORT $L101404

; 1587 : 	{
; 1588 : 		int nPX, nPY;
; 1589 : 		Npc[m_nLauncher].GetMpsPos(&nPX, &nPY);

	lea	eax, DWORD PTR _nPY$101403[esp+32]
	lea	ecx, DWORD PTR _nPX$101402[esp+32]
	push	eax
	push	ecx
	mov	ecx, DWORD PTR [esi+332]
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	lea	edx, DWORD PTR [eax+eax*8]
	lea	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[edx*4]
	call	?GetMpsPos@KNpc@@QAEXPAH0@Z		; KNpc::GetMpsPos

; 1590 : 		if (nPX != m_nLauncherSrcPX || nPY != m_nLauncherSrcPY)

	mov	eax, DWORD PTR _nPX$101402[esp+32]
	mov	ecx, DWORD PTR [esi+136]
	cmp	eax, ecx
	jne	SHORT $L101405
	mov	ecx, DWORD PTR _nPY$101403[esp+32]
	mov	eax, DWORD PTR [esi+140]
	cmp	ecx, eax
	je	SHORT $L101404
$L101405:
	pop	edi
	pop	esi
	pop	ebp

; 1591 : 		{
; 1592 : 			return false;

	xor	eax, eax
	pop	ebx

; 1643 : 	
; 1644 : }

	add	esp, 16					; 00000010H
	ret	0
$L101404:

; 1593 : 		}
; 1594 : 	}
; 1595 : 	
; 1596 : 	if (m_bHeelAtParent)

	mov	eax, DWORD PTR [esi+132]
	test	eax, eax
	je	$L101423

; 1597 : 	{
; 1598 : 		int nNewPX = 0;
; 1599 : 		int nNewPY = 0;
; 1600 : 		
; 1601 : 		if (m_nParentMissleIndex)

	mov	ecx, DWORD PTR [esi+340]
	test	ecx, ecx
	je	SHORT $L101409

; 1602 : 		{
; 1603 : 			if (Missle[m_nParentMissleIndex].m_dwLauncherId != m_dwLauncherId)

	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	mov	ecx, DWORD PTR [esi+336]
	shl	eax, 7
	mov	edx, DWORD PTR ?Missle@@3PAVKMissle@@A[eax+336]
	cmp	edx, ecx
	je	SHORT $L101410
	pop	edi
	pop	esi
	pop	ebp

; 1604 : 			{
; 1605 : 				return false;

	xor	eax, eax
	pop	ebx

; 1643 : 	
; 1644 : }

	add	esp, 16					; 00000010H
	ret	0
$L101410:

; 1606 : 			}
; 1607 : 			else
; 1608 : 			{
; 1609 : 				int nParentPX, nParentPY;
; 1610 : 				int nSrcPX, nSrcPY;
; 1611 : 				Missle[m_nParentMissleIndex].GetMpsPos(&nParentPX, &nParentPY);

	lea	ecx, DWORD PTR _nParentPY$101413[esp+32]
	lea	edx, DWORD PTR _nParentPX$101412[esp+32]
	push	ecx
	push	edx
	lea	ecx, DWORD PTR ?Missle@@3PAVKMissle@@A[eax]
	call	?GetMpsPos@KMissle@@QAEXPAH0@Z		; KMissle::GetMpsPos

; 1612 : 				GetMpsPos(&nSrcPX, &nSrcPY);

	lea	eax, DWORD PTR _nSrcPY$101415[esp+32]
	lea	ecx, DWORD PTR _nSrcPX$101414[esp+32]
	push	eax
	push	ecx
	mov	ecx, esi
	call	?GetMpsPos@KMissle@@QAEXPAH0@Z		; KMissle::GetMpsPos

; 1613 : 				nNewPX = nSrcPX + (nParentPX - m_nRefPX);

	mov	ebx, DWORD PTR _nSrcPX$101414[esp+32]
	mov	edi, DWORD PTR [esi+236]
	mov	edx, DWORD PTR _nParentPX$101412[esp+32]

; 1614 : 				nNewPY = nSrcPY + (nParentPY - m_nRefPY);

	mov	ebp, DWORD PTR _nSrcPY$101415[esp+32]
	mov	ecx, DWORD PTR [esi+240]
	mov	eax, DWORD PTR _nParentPY$101413[esp+32]
	sub	ebx, edi
	add	ebx, edx
	sub	ebp, ecx

; 1615 : 			}
; 1616 : 		}
; 1617 : 		else

	jmp	SHORT $L106537
$L101409:

; 1618 : 		{
; 1619 : 			_ASSERT(m_nLauncher > 0);
; 1620 : 			int nParentPX, nParentPY;
; 1621 : 			int nSrcPX, nSrcPY;
; 1622 : 			
; 1623 : 			Npc[m_nLauncher].GetMpsPos(&nParentPX, &nParentPY);

	mov	ecx, DWORD PTR [esi+332]
	lea	edx, DWORD PTR _nParentPY$101419[esp+32]
	lea	eax, DWORD PTR _nParentPX$101418[esp+32]
	push	edx
	push	eax
	lea	eax, DWORD PTR [ecx+ecx*2]
	shl	eax, 3
	sub	eax, ecx
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, ecx
	lea	ecx, DWORD PTR [eax+eax*8]
	lea	ecx, DWORD PTR ?Npc@@3PAVKNpc@@A[ecx*4]
	call	?GetMpsPos@KNpc@@QAEXPAH0@Z		; KNpc::GetMpsPos

; 1624 : 			GetMpsPos(&nSrcPX, &nSrcPY);

	lea	edx, DWORD PTR _nSrcPY$101421[esp+32]
	lea	eax, DWORD PTR _nSrcPX$101420[esp+32]
	push	edx
	push	eax
	mov	ecx, esi
	call	?GetMpsPos@KMissle@@QAEXPAH0@Z		; KMissle::GetMpsPos

; 1625 : 			
; 1626 : 			nNewPX = nSrcPX + (nParentPX - m_nRefPX);

	mov	ebx, DWORD PTR _nSrcPX$101420[esp+32]
	mov	edi, DWORD PTR [esi+236]
	mov	edx, DWORD PTR _nParentPX$101418[esp+32]

; 1627 : 			nNewPY = nSrcPY + (nParentPY - m_nRefPY);

	mov	ebp, DWORD PTR _nSrcPY$101421[esp+32]
	mov	ecx, DWORD PTR [esi+240]
	mov	eax, DWORD PTR _nParentPY$101419[esp+32]
	sub	ebx, edi
	add	ebx, edx
	sub	ebp, ecx
$L106537:

; 1628 : 		}
; 1629 : 		
; 1630 : 		int nOldRegion = m_nRegionId;
; 1631 : 		CurRegion.DecRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	ecx, DWORD PTR [esi+220]
	mov	edx, DWORD PTR [esi+216]
	push	2
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	lea	edi, DWORD PTR [esi+364]
	push	edx
	mov	edx, ecx
	add	ebp, eax
	mov	eax, DWORD PTR [edi]
	shl	edx, 6
	sub	edx, ecx
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	DWORD PTR _nOldRegion$101422[esp+44], eax
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+40]
	shl	eax, 4
	add	ecx, eax
	call	?DecRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::DecRef

; 1632 : 		SubWorld[m_nSubWorldId].Mps2Map(nNewPX, nNewPY, &m_nRegionId, &m_nCurrentMapX, &m_nCurrentMapY, &m_nXOffset, &m_nYOffset);

	lea	ecx, DWORD PTR [esi+232]
	lea	edx, DWORD PTR [esi+228]
	push	ecx
	lea	eax, DWORD PTR [esi+220]
	push	edx
	push	eax
	lea	eax, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, eax
	push	edi
	shl	ecx, 6
	sub	ecx, eax
	push	ebp
	push	ebx
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4]
	call	?Mps2Map@KSubWorld@@QAEXHHPAH0000@Z	; KSubWorld::Mps2Map

; 1633 : 		CurRegion.AddRef(m_nCurrentMapX, m_nCurrentMapY, obj_missle);

	mov	edx, DWORD PTR [esi+220]
	mov	eax, DWORD PTR [esi+216]
	push	2
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, eax
	shl	ecx, 6
	sub	ecx, eax
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4+40]
	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+edx*4]
	shl	eax, 4
	add	ecx, eax
	call	?AddRef@KRegion@@QAEHHHW4MOVE_OBJ_KIND@@@Z ; KRegion::AddRef

; 1634 : 		
; 1635 : 		if (nOldRegion != m_nRegionId)

	mov	edi, DWORD PTR [edi]
	mov	eax, DWORD PTR _nOldRegion$101422[esp+32]
	cmp	eax, edi
	je	SHORT $L101423

; 1636 : 		{
; 1637 : 			SubWorld[m_nSubWorldId].m_WorldMessage.Send(GWM_MISSLE_CHANGE_REGION, nOldRegion, m_nRegionId, m_nMissleId);

	mov	ecx, DWORD PTR [esi+356]
	mov	esi, DWORD PTR [esi+360]
	mov	edx, esi
	push	ecx
	shl	edx, 6
	sub	edx, esi
	push	edi
	push	eax
	push	4002					; 00000fa2H
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+204]
	call	?Send@KWorldMsg@@QAEHKHHH@Z		; KWorldMsg::Send
$L101423:
	pop	edi
	pop	esi
	pop	ebp

; 1638 : 		} 
; 1639 : 		
; 1640 : 	}
; 1641 : 	
; 1642 : 	return true;

	mov	eax, 1
	pop	ebx

; 1643 : 	
; 1644 : }

	add	esp, 16					; 00000010H
	ret	0
?PrePareFly@KMissle@@AAEHXZ ENDP			; KMissle::PrePareFly
_TEXT	ENDS
PUBLIC	?CheckNearestCollision@KMissle@@AAEHXZ		; KMissle::CheckNearestCollision
;	COMDAT ?CheckNearestCollision@KMissle@@AAEHXZ
_TEXT	SEGMENT
_nSearchRegion$ = -16
_nRMx$ = -20
_nRMy$ = -24
_nNpcOffsetX$ = -12
_nNpcOffsetY$ = -8
_i$ = -28
_j$101445 = -4
?CheckNearestCollision@KMissle@@AAEHXZ PROC NEAR	; KMissle::CheckNearestCollision, COMDAT

; 1647 : {

	sub	esp, 28					; 0000001cH
	push	ebx
	push	ebp

; 1648 : 	int nSearchRegion = 0;

	xor	eax, eax
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR _nSearchRegion$[esp+44], eax

; 1649 : 	int nRMx = 0;

	mov	DWORD PTR _nRMx$[esp+44], eax

; 1650 : 	int nRMy = 0;

	mov	DWORD PTR _nRMy$[esp+44], eax

; 1651 : 	BOOL bCollision = TRUE;
; 1652 : 	int nNpcIdx = 0;
; 1653 : 	int nDX = 0;
; 1654 : 	int nDY = 0;
; 1655 : 	int nNpcOffsetX = 0;
; 1656 : 	int nNpcOffsetY = 0;
; 1657 : 	int nAbsX = 0;
; 1658 : 	int nAbsY = 0;
; 1659 : 	int nCellWidth = CellWidth;
; 1660 : 	int nCellHeight = CellHeight;
; 1661 : 	_ASSERT(nCellWidth > 0 && nCellHeight > 0);
; 1662 : 	
; 1663 : 	for (int i = -1; i <= 1; i ++)

	mov	DWORD PTR _i$[esp+44], -1
$L101442:

; 1664 : 		for (int j = -1; j <= 1; j ++)

	or	eax, -1
	mov	DWORD PTR _j$101445[esp+44], eax
$L101446:

; 1665 : 		{
; 1666 : 			if (!KMissle::GetOffsetAxis(
; 1667 : 				m_nSubWorldId,
; 1668 : 				m_nRegionId, 
; 1669 : 				m_nCurrentMapX, 
; 1670 : 				m_nCurrentMapY, 
; 1671 : 				i , 
; 1672 : 				j , 
; 1673 : 				nSearchRegion, 
; 1674 : 				nRMx, 
; 1675 : 				nRMy
; 1676 : 				))

	lea	ecx, DWORD PTR _nRMy$[esp+44]
	lea	edx, DWORD PTR _nRMx$[esp+44]
	push	ecx
	lea	ecx, DWORD PTR _nSearchRegion$[esp+48]
	push	edx
	mov	edx, DWORD PTR _i$[esp+52]
	push	ecx
	mov	ecx, DWORD PTR [esi+216]
	push	eax
	mov	eax, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+364]
	push	eax
	mov	eax, DWORD PTR [esi+360]
	push	ecx
	push	edx
	push	eax
	call	?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z ; KMissle::GetOffsetAxis
	add	esp, 36					; 00000024H
	test	eax, eax
	je	$L101447

; 1677 : 				continue;
; 1678 : 			
; 1679 : 			_ASSERT(nSearchRegion >= 0);
; 1680 : 			
; 1681 : 			nNpcIdx = SubWorld[m_nSubWorldId].m_Region[nSearchRegion].FindNpc(nRMx, nRMy, m_nLauncher, m_eRelation);

	mov	ecx, DWORD PTR [esi+108]
	mov	edx, DWORD PTR [esi+332]
	mov	eax, DWORD PTR _nRMy$[esp+44]
	push	ecx
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, DWORD PTR _nRMx$[esp+56]
	mov	edx, eax
	push	ecx
	shl	edx, 6
	sub	edx, eax
	mov	eax, DWORD PTR _nSearchRegion$[esp+60]
	lea	ecx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4+40]
	shl	eax, 4
	add	ecx, eax
	call	?FindNpc@KRegion@@QAEHHHHH@Z		; KRegion::FindNpc
	mov	edi, eax

; 1682 : 			
; 1683 : 			if (nNpcIdx > 0)

	test	edi, edi
	jle	$L101447

; 1684 : 			{
; 1685 : 				bCollision = TRUE;
; 1686 : 				nDX = m_nCurrentMapX - Npc[nNpcIdx].m_MapX;

	lea	eax, DWORD PTR [edi+edi*2]
	mov	ecx, DWORD PTR [esi+216]
	shl	eax, 3
	sub	eax, edi
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 4
	add	eax, edi
	lea	eax, DWORD PTR [eax+eax*8]
	shl	eax, 2
	mov	ebx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3112]

; 1687 : 				nDY = m_nCurrentMapY - Npc[nNpcIdx].m_MapY;

	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3116]
	sub	ecx, ebx
	mov	ebx, DWORD PTR [esi+220]
	sub	ebx, edx

; 1688 : 				nNpcOffsetX = Npc[nNpcIdx].m_OffX;

	mov	edx, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3124]

; 1689 : 				nNpcOffsetY = Npc[nNpcIdx].m_OffY;

	mov	eax, DWORD PTR ?Npc@@3PAVKNpc@@A[eax+3128]
	mov	DWORD PTR _nNpcOffsetX$[esp+44], edx
	mov	DWORD PTR _nNpcOffsetY$[esp+44], eax

; 1690 : 				nAbsX = abs(nDX);
; 1691 : 				nAbsY = abs(nDY);

	mov	eax, ebx
	cdq
	mov	ebp, eax
	mov	eax, ecx
	xor	ebp, edx
	sub	ebp, edx
	cdq
	xor	eax, edx
	sub	eax, edx

; 1692 : 				
; 1693 : 				if (nAbsX)

	je	SHORT $L101459

; 1694 : 				{
; 1695 : 					if (nDX < 0)

	test	ecx, ecx
	jge	SHORT $L106551

; 1696 : 					{
; 1697 : 						if (nCellWidth - m_nXOffset + nNpcOffsetX > nCellWidth)

	mov	eax, DWORD PTR _nNpcOffsetX$[esp+44]
	mov	ecx, DWORD PTR [esi+228]
	sub	eax, ecx
	add	eax, 32768				; 00008000H
	cmp	eax, 32768				; 00008000H

; 1741 : }

	jg	SHORT $L101447

; 1698 : 						{
; 1699 : 							bCollision = FALSE;
; 1700 : 							goto CheckCollision;
; 1701 : 						}
; 1702 : 					}
; 1703 : 					else if (nDX > 0)

	jmp	SHORT $L101459
$L106551:
	jle	SHORT $L101459

; 1704 : 					{
; 1705 : 						if (nCellWidth - nNpcOffsetX + m_nXOffset > nCellWidth)

	mov	ecx, DWORD PTR [esi+228]
	mov	eax, DWORD PTR _nNpcOffsetX$[esp+44]
	sub	ecx, eax
	add	ecx, 32768				; 00008000H
	cmp	ecx, 32768				; 00008000H

; 1741 : }

	jg	SHORT $L101447
$L101459:

; 1706 : 						{
; 1707 : 							bCollision = FALSE;
; 1708 : 							goto CheckCollision;
; 1709 : 						}
; 1710 : 					}
; 1711 : 				}
; 1712 : 				
; 1713 : 				if (nAbsY)

	test	ebp, ebp
	je	SHORT $L106543

; 1714 : 				{
; 1715 : 					if (nDY <0)

	test	ebx, ebx
	jge	SHORT $L106552

; 1716 : 					{
; 1717 : 						if (nCellHeight - m_nYOffset + nNpcOffsetY > nCellHeight)

	mov	eax, DWORD PTR _nNpcOffsetY$[esp+44]
	mov	ebx, DWORD PTR [esi+232]
	sub	eax, ebx
	add	eax, 32768				; 00008000H
	cmp	eax, 32768				; 00008000H
	jle	SHORT $L106543

; 1741 : }

	jmp	SHORT $L101447
$L106552:

; 1718 : 						{
; 1719 : 							bCollision = FALSE;
; 1720 : 							goto CheckCollision;
; 1721 : 						}
; 1722 : 					}
; 1723 : 					else if (nDY >0)

	jle	SHORT $L106543

; 1724 : 					{
; 1725 : 						if (nCellHeight - nNpcOffsetY + m_nYOffset > nCellHeight)

	mov	edx, DWORD PTR [esi+232]
	mov	ebx, DWORD PTR _nNpcOffsetY$[esp+44]
	sub	edx, ebx
	add	edx, 32768				; 00008000H
	cmp	edx, 32768				; 00008000H
	jle	SHORT $L106543
$L101447:

; 1664 : 		for (int j = -1; j <= 1; j ++)

	mov	eax, DWORD PTR _j$101445[esp+44]
	inc	eax
	cmp	eax, 1
	mov	DWORD PTR _j$101445[esp+44], eax
	jle	$L101446
	mov	eax, DWORD PTR _i$[esp+44]
	inc	eax
	cmp	eax, 1
	mov	DWORD PTR _i$[esp+44], eax
	jle	$L101442
	pop	edi
	pop	esi
	pop	ebp

; 1737 : 			}
; 1738 : 		}
; 1739 : 		
; 1740 : 		return 0;

	xor	eax, eax
	pop	ebx

; 1741 : }

	add	esp, 28					; 0000001cH
	ret	0
$L106543:

; 1726 : 						{
; 1727 : 							bCollision = FALSE;
; 1728 : 							goto CheckCollision;
; 1729 : 						}
; 1730 : 					}
; 1731 : 				}
; 1732 : 				
; 1733 : 				
; 1734 : CheckCollision:
; 1735 : 				if (bCollision)
; 1736 : 					return nNpcIdx;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1741 : }

	add	esp, 28					; 0000001cH
	ret	0
?CheckNearestCollision@KMissle@@AAEHXZ ENDP		; KMissle::CheckNearestCollision
_TEXT	ENDS
;	COMDAT ?FindNearestCollision@KMissle@@AAEHHH@Z
_TEXT	SEGMENT
_nLauncher$ = 8
_nRelation$ = 12
_nSearchRegion$ = -4
_nRMx$ = -8
_nRMy$ = -12
_i$ = -16
?FindNearestCollision@KMissle@@AAEHHH@Z PROC NEAR	; KMissle::FindNearestCollision, COMDAT

; 1745 : {

	sub	esp, 16					; 00000010H
	push	ebx

; 1754 : 		{
; 1755 : 			if (!KMissle::GetOffsetAxis(
; 1756 : 				m_nSubWorldId,
; 1757 : 				m_nRegionId, 
; 1758 : 				m_nCurrentMapX, 
; 1759 : 				m_nCurrentMapY, 
; 1760 : 				i , 
; 1761 : 				j , 
; 1762 : 				nSearchRegion, 
; 1763 : 				nRMx, 
; 1764 : 				nRMy
; 1765 : 				))

	mov	ebx, DWORD PTR _nRelation$[esp+16]
	push	ebp
	mov	ebp, DWORD PTR _nLauncher$[esp+20]
	xor	eax, eax
	push	esi
	push	edi
	mov	esi, ecx
	mov	DWORD PTR _nSearchRegion$[esp+32], eax
	mov	DWORD PTR _nRMx$[esp+32], eax
	mov	DWORD PTR _nRMy$[esp+32], eax
	mov	DWORD PTR _i$[esp+32], -1
$L101480:

; 1746 : 	int nSearchRegion = 0;
; 1747 : 	int nRMx = 0;
; 1748 : 	int nRMy = 0;
; 1749 : 	int nNpcIdx = 0;
; 1750 : 
; 1751 : 	for (int i = -1; i <= 1; i ++)
; 1752 : 	{
; 1753 : 		for (int j = -1; j <= 1; j ++)

	or	edi, -1
$L101484:

; 1754 : 		{
; 1755 : 			if (!KMissle::GetOffsetAxis(
; 1756 : 				m_nSubWorldId,
; 1757 : 				m_nRegionId, 
; 1758 : 				m_nCurrentMapX, 
; 1759 : 				m_nCurrentMapY, 
; 1760 : 				i , 
; 1761 : 				j , 
; 1762 : 				nSearchRegion, 
; 1763 : 				nRMx, 
; 1764 : 				nRMy
; 1765 : 				))

	lea	eax, DWORD PTR _nRMy$[esp+32]
	lea	ecx, DWORD PTR _nRMx$[esp+32]
	push	eax
	mov	eax, DWORD PTR _i$[esp+36]
	lea	edx, DWORD PTR _nSearchRegion$[esp+36]
	push	ecx
	mov	ecx, DWORD PTR [esi+220]
	push	edx
	mov	edx, DWORD PTR [esi+216]
	push	edi
	push	eax
	mov	eax, DWORD PTR [esi+364]
	push	ecx
	mov	ecx, DWORD PTR [esi+360]
	push	edx
	push	eax
	push	ecx
	call	?GetOffsetAxis@KMissle@@SAHHHHHHHAAH00@Z ; KMissle::GetOffsetAxis
	add	esp, 36					; 00000024H
	test	eax, eax
	je	SHORT $L101485

; 1766 : 				continue;
; 1767 : 			
; 1768 : 			_ASSERT(nSearchRegion >= 0);
; 1769 : 			
; 1770 : 			nNpcIdx = SubWorld[m_nSubWorldId].m_Region[nSearchRegion].FindNpc(nRMx, nRMy, nLauncher, nRelation);

	mov	edx, DWORD PTR _nRMy$[esp+32]
	mov	eax, DWORD PTR _nRMx$[esp+32]
	push	ebx
	push	ebp
	push	edx
	push	eax
	mov	eax, DWORD PTR [esi+360]
	mov	ecx, eax
	shl	ecx, 6
	sub	ecx, eax
	mov	eax, DWORD PTR _nSearchRegion$[esp+48]
	mov	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[ecx*4+40]
	lea	edx, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax+edx*4]
	shl	eax, 4
	add	ecx, eax
	call	?FindNpc@KRegion@@QAEHHHHH@Z		; KRegion::FindNpc

; 1771 : 			
; 1772 : 			if (nNpcIdx > 0)

	test	eax, eax
	jg	SHORT $L101474
$L101485:

; 1746 : 	int nSearchRegion = 0;
; 1747 : 	int nRMx = 0;
; 1748 : 	int nRMy = 0;
; 1749 : 	int nNpcIdx = 0;
; 1750 : 
; 1751 : 	for (int i = -1; i <= 1; i ++)
; 1752 : 	{
; 1753 : 		for (int j = -1; j <= 1; j ++)

	inc	edi
	cmp	edi, 1
	jle	SHORT $L101484
	mov	eax, DWORD PTR _i$[esp+32]
	inc	eax
	cmp	eax, 1
	mov	DWORD PTR _i$[esp+32], eax
	jle	$L101480

; 1773 : 				return nNpcIdx;
; 1774 : 		}
; 1775 : 	}
; 1776 : 	return 0;

	xor	eax, eax
$L101474:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 1777 : }

	add	esp, 16					; 00000010H
	ret	8
?FindNearestCollision@KMissle@@AAEHHH@Z ENDP		; KMissle::FindNearestCollision
_TEXT	ENDS
;	COMDAT ?GetMpsPos@KMissle@@QAEXPAH0@Z
_TEXT	SEGMENT
_pPosX$ = 8
_pPosY$ = 12
?GetMpsPos@KMissle@@QAEXPAH0@Z PROC NEAR		; KMissle::GetMpsPos, COMDAT

; 1781 : 	SubWorld[m_nSubWorldId].Map2Mps(m_nRegionId, m_nCurrentMapX, m_nCurrentMapY, m_nXOffset, m_nYOffset, pPosX, pPosY);

	mov	eax, DWORD PTR _pPosY$[esp-4]
	mov	edx, DWORD PTR _pPosX$[esp-4]
	push	eax
	mov	eax, DWORD PTR [ecx+232]
	push	edx
	mov	edx, DWORD PTR [ecx+228]
	push	eax
	mov	eax, DWORD PTR [ecx+220]
	push	edx
	mov	edx, DWORD PTR [ecx+216]
	push	eax
	mov	eax, DWORD PTR [ecx+364]
	mov	ecx, DWORD PTR [ecx+360]
	push	edx
	mov	edx, ecx
	push	eax
	shl	edx, 6
	sub	edx, ecx
	lea	ecx, DWORD PTR ?SubWorld@@3PAVKSubWorld@@A[edx*4]
	call	?Map2Mps@KSubWorld@@QAEXHHHHHPAH0@Z	; KSubWorld::Map2Mps

; 1782 : };

	ret	8
?GetMpsPos@KMissle@@QAEXPAH0@Z ENDP			; KMissle::GetMpsPos
_TEXT	ENDS
END
